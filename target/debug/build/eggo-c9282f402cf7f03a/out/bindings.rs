/* automatically generated by rust-bindgen */

#[allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
pub mod root {
    #[allow(unused_imports)]
    use self::super::root;
    pub mod std {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type size_t = ::std::os::raw::c_ulong;
        pub type string = [u64; 4usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string {
            pub _address: u8,
        }
        pub type basic_string__Char_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type basic_string__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type basic_string_traits_type<_Traits> = _Traits;
        pub type basic_string_value_type = [u8; 0usize];
        pub type basic_string_allocator_type = root::std::basic_string__Char_alloc_type;
        pub type basic_string_size_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_difference_type = root::std::basic_string__Alloc_traits;
        pub type basic_string_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_reference = root::std::basic_string__Alloc_traits;
        pub type basic_string_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_const_pointer = root::std::basic_string__Alloc_traits;
        pub type basic_string_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_pointer>;
        pub type basic_string_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::basic_string_const_pointer>;
        pub type basic_string_const_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_const_iterator>;
        pub type basic_string_reverse_iterator =
            root::std::reverse_iterator<root::std::basic_string_iterator>;
        pub type basic_string___const_iterator = root::std::basic_string_const_iterator;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_string__Alloc_hider {
            pub _M_p: root::std::basic_string_pointer,
        }
        pub const basic_string__S_local_capacity: root::std::basic_string__bindgen_ty_1 = 0;
        pub type basic_string__bindgen_ty_1 = i32;
        #[repr(C)]
        pub union basic_string__bindgen_ty_2<_CharT> {
            pub _M_local_buf: *mut _CharT,
            pub _M_allocated_capacity: root::std::basic_string_size_type,
            _bindgen_union_align: u64,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type integral_constant_value_type<_Tp> = _Tp;
        pub type integral_constant_type = u8;
        pub type true_type = u8;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __and_ {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct pair<_T1, _T2> {
            pub first: _T1,
            pub second: _T2,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T1>>,
            pub _phantom_1: ::std::marker::PhantomData<::std::cell::UnsafeCell<_T2>>,
        }
        pub type pair_first_type<_T1> = _T1;
        pub type pair_second_type<_T2> = _T2;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct input_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_input_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<input_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(input_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<input_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(input_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct output_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_output_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<output_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(output_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<output_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(output_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct forward_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_forward_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<forward_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(forward_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<forward_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(forward_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct bidirectional_iterator_tag {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_bidirectional_iterator_tag() {
            assert_eq!(
                ::std::mem::size_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Size of: ", stringify!(bidirectional_iterator_tag))
            );
            assert_eq!(
                ::std::mem::align_of::<bidirectional_iterator_tag>(),
                1usize,
                concat!("Alignment of ", stringify!(bidirectional_iterator_tag))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator {
            pub _address: u8,
        }
        pub type iterator_iterator_category<_Category> = _Category;
        pub type iterator_value_type<_Tp> = _Tp;
        pub type iterator_difference_type<_Distance> = _Distance;
        pub type iterator_pointer<_Pointer> = _Pointer;
        pub type iterator_reference<_Reference> = _Reference;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct iterator_traits {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct reverse_iterator<_Iterator> {
            pub current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type reverse_iterator___traits_type = root::std::iterator_traits;
        pub type reverse_iterator_iterator_type<_Iterator> = _Iterator;
        pub type reverse_iterator_difference_type = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_pointer = root::std::reverse_iterator___traits_type;
        pub type reverse_iterator_reference = root::std::reverse_iterator___traits_type;
        #[repr(C)]
        pub struct exception__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct exception {
            pub vtable_: *const exception__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_exception() {
            assert_eq!(
                ::std::mem::size_of::<exception>(),
                8usize,
                concat!("Size of: ", stringify!(exception))
            );
            assert_eq!(
                ::std::mem::align_of::<exception>(),
                8usize,
                concat!("Alignment of ", stringify!(exception))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionC1Ev"]
            pub fn exception_exception(this: *mut root::std::exception);
        }
        impl exception {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                exception_exception(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt9exceptionD1Ev"]
            pub fn exception_exception_destructor(this: *mut root::std::exception);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt9exception4whatEv"]
            pub fn exception_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        pub type __allocator_base = root::__gnu_cxx::new_allocator;
        #[repr(C)]
        #[derive(Debug)]
        pub struct allocator {
            pub _address: u8,
        }
        pub type allocator_size_type = root::std::size_t;
        pub type allocator_difference_type = isize;
        pub type allocator_pointer<_Tp> = *mut _Tp;
        pub type allocator_const_pointer<_Tp> = *const _Tp;
        pub type allocator_reference<_Tp> = *mut _Tp;
        pub type allocator_const_reference<_Tp> = *const _Tp;
        pub type allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_rebind {
            pub _address: u8,
        }
        pub type allocator_rebind_other = root::std::allocator;
        pub type allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct unary_function {
            pub _address: u8,
        }
        pub type unary_function_argument_type<_Arg> = _Arg;
        pub type unary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct binary_function {
            pub _address: u8,
        }
        pub type binary_function_first_argument_type<_Arg1> = _Arg1;
        pub type binary_function_second_argument_type<_Arg2> = _Arg2;
        pub type binary_function_result_type<_Result> = _Result;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Identity {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Select1st {
            pub _address: u8,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits {
            pub _address: u8,
        }
        pub type allocator_traits_allocator_type<_Alloc> = _Alloc;
        pub type allocator_traits_value_type = [u8; 0usize];
        pub type allocator_traits___pointer<_Alloc> = _Alloc;
        pub type allocator_traits_pointer<_Alloc> = root::std::allocator_traits___pointer<_Alloc>;
        pub type allocator_traits___const_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_pointer<_Alloc> =
            root::std::allocator_traits___const_pointer<_Alloc>;
        pub type allocator_traits___void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_void_pointer<_Alloc> =
            root::std::allocator_traits___void_pointer<_Alloc>;
        pub type allocator_traits___const_void_pointer<_Alloc> = _Alloc;
        pub type allocator_traits_const_void_pointer<_Alloc> =
            root::std::allocator_traits___const_void_pointer<_Alloc>;
        pub type allocator_traits___difference_type<_Alloc> = _Alloc;
        pub type allocator_traits_difference_type<_Alloc> =
            root::std::allocator_traits___difference_type<_Alloc>;
        pub type allocator_traits___size_type<_Alloc> = _Alloc;
        pub type allocator_traits_size_type<_Alloc> =
            root::std::allocator_traits___size_type<_Alloc>;
        pub type allocator_traits___propagate_on_container_copy_assignment<_Alloc> = _Alloc;
        pub type allocator_traits_propagate_on_container_copy_assignment<_Alloc> =
            root::std::allocator_traits___propagate_on_container_copy_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_move_assignment<_Alloc> = _Alloc;
        pub type allocator_traits_propagate_on_container_move_assignment<_Alloc> =
            root::std::allocator_traits___propagate_on_container_move_assignment<_Alloc>;
        pub type allocator_traits___propagate_on_container_swap<_Alloc> = _Alloc;
        pub type allocator_traits_propagate_on_container_swap<_Alloc> =
            root::std::allocator_traits___propagate_on_container_swap<_Alloc>;
        pub type allocator_traits_rebind_alloc = u8;
        pub type allocator_traits_rebind_traits = root::std::allocator_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___allocate_helper {
            pub _address: u8,
        }
        pub type allocator_traits___allocate_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_allocate = root::std::allocator_traits___allocate_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___construct_helper {
            pub _address: u8,
        }
        pub type allocator_traits___construct_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_construct = root::std::allocator_traits___construct_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___destroy_helper {
            pub _address: u8,
        }
        pub type allocator_traits___destroy_helper_type<_Alloc> = _Alloc;
        pub type allocator_traits___has_destroy = root::std::allocator_traits___destroy_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___maxsize_helper {
            pub _address: u8,
        }
        pub type allocator_traits___maxsize_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_max_size = root::std::allocator_traits___maxsize_helper;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct allocator_traits___select_helper {
            pub _address: u8,
        }
        pub type allocator_traits___select_helper_type<_Alloc2> = _Alloc2;
        pub type allocator_traits___has_soccc = root::std::allocator_traits___select_helper;
        pub const _Rb_tree_color__S_red: root::std::_Rb_tree_color = 0;
        pub const _Rb_tree_color__S_black: root::std::_Rb_tree_color = 1;
        pub type _Rb_tree_color = u32;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_node_base {
            pub _M_color: root::std::_Rb_tree_color,
            pub _M_parent: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_left: root::std::_Rb_tree_node_base__Base_ptr,
            pub _M_right: root::std::_Rb_tree_node_base__Base_ptr,
        }
        pub type _Rb_tree_node_base__Base_ptr = *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree_node_base__Const_Base_ptr = *const root::std::_Rb_tree_node_base;
        #[test]
        fn bindgen_test_layout__Rb_tree_node_base() {
            assert_eq!(
                ::std::mem::size_of::<_Rb_tree_node_base>(),
                32usize,
                concat!("Size of: ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                ::std::mem::align_of::<_Rb_tree_node_base>(),
                8usize,
                concat!("Alignment of ", stringify!(_Rb_tree_node_base))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_color as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_color)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_parent as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_parent)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_left as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_left)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<_Rb_tree_node_base>()))._M_right as *const _ as usize
                },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(_Rb_tree_node_base),
                    "::",
                    stringify!(_M_right)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_minimumEPS_"]
            pub fn _Rb_tree_node_base__S_minimum(
                __x: root::std::_Rb_tree_node_base__Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_minimumEPKS_"]
            pub fn _Rb_tree_node_base__S_minimum1(
                __x: root::std::_Rb_tree_node_base__Const_Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Const_Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_maximumEPS_"]
            pub fn _Rb_tree_node_base__S_maximum(
                __x: root::std::_Rb_tree_node_base__Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Base_ptr;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_maximumEPKS_"]
            pub fn _Rb_tree_node_base__S_maximum1(
                __x: root::std::_Rb_tree_node_base__Const_Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Const_Base_ptr;
        }
        impl _Rb_tree_node_base {
            #[inline]
            pub unsafe fn _S_minimum(
                __x: root::std::_Rb_tree_node_base__Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_minimum(__x)
            }
            #[inline]
            pub unsafe fn _S_minimum1(
                __x: root::std::_Rb_tree_node_base__Const_Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_minimum1(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum(
                __x: root::std::_Rb_tree_node_base__Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Base_ptr {
                _Rb_tree_node_base__S_maximum(__x)
            }
            #[inline]
            pub unsafe fn _S_maximum1(
                __x: root::std::_Rb_tree_node_base__Const_Base_ptr,
            ) -> root::std::_Rb_tree_node_base__Const_Base_ptr {
                _Rb_tree_node_base__S_maximum1(__x)
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_node {
            pub _base: root::std::_Rb_tree_node_base,
            pub _M_storage: root::__gnu_cxx::__aligned_membuf,
        }
        pub type _Rb_tree_node__Link_type = *mut root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_iterator {
            pub _M_node: root::std::_Rb_tree_iterator__Base_ptr,
        }
        pub type _Rb_tree_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_iterator_reference<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_pointer<_Tp> = *mut _Tp;
        pub type _Rb_tree_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_iterator_difference_type = isize;
        pub type _Rb_tree_iterator__Self = root::std::_Rb_tree_iterator;
        pub type _Rb_tree_iterator__Base_ptr = root::std::_Rb_tree_node_base__Base_ptr;
        pub type _Rb_tree_iterator__Link_type = *mut root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree_const_iterator {
            pub _M_node: root::std::_Rb_tree_const_iterator__Base_ptr,
        }
        pub type _Rb_tree_const_iterator_value_type<_Tp> = _Tp;
        pub type _Rb_tree_const_iterator_reference<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_pointer<_Tp> = *const _Tp;
        pub type _Rb_tree_const_iterator_iterator = root::std::_Rb_tree_iterator;
        pub type _Rb_tree_const_iterator_iterator_category = root::std::bidirectional_iterator_tag;
        pub type _Rb_tree_const_iterator_difference_type = isize;
        pub type _Rb_tree_const_iterator__Self = root::std::_Rb_tree_const_iterator;
        pub type _Rb_tree_const_iterator__Base_ptr = root::std::_Rb_tree_node_base__Const_Base_ptr;
        pub type _Rb_tree_const_iterator__Link_type = *const root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Rb_tree {
            pub _M_impl: u8,
        }
        pub type _Rb_tree__Node_allocator = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type _Rb_tree__Base_ptr = *mut root::std::_Rb_tree_node_base;
        pub type _Rb_tree__Const_Base_ptr = *const root::std::_Rb_tree_node_base;
        pub type _Rb_tree__Link_type = *mut root::std::_Rb_tree_node;
        pub type _Rb_tree__Const_Link_type = *const root::std::_Rb_tree_node;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Rb_tree__Reuse_or_alloc_node {
            pub _M_root: root::std::_Rb_tree__Base_ptr,
            pub _M_nodes: root::std::_Rb_tree__Base_ptr,
            pub _M_t: *mut root::std::_Rb_tree,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Rb_tree__Alloc_node {
            pub _M_t: *mut root::std::_Rb_tree,
        }
        pub type _Rb_tree_key_type<_Key> = _Key;
        pub type _Rb_tree_value_type<_Val> = _Val;
        pub type _Rb_tree_pointer<_Val> = *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_pointer<_Val> = *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_reference<_Val> = *mut root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_const_reference<_Val> = *const root::std::_Rb_tree_value_type<_Val>;
        pub type _Rb_tree_size_type = root::std::size_t;
        pub type _Rb_tree_difference_type = isize;
        pub type _Rb_tree_allocator_type<_Alloc> = _Alloc;
        pub type _Rb_tree_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_iterator>;
        pub type _Rb_tree_const_reverse_iterator =
            root::std::reverse_iterator<root::std::_Rb_tree_const_iterator>;
        pub type streamoff = ::std::os::raw::c_long;
        pub type streamsize = isize;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct fpos<_StateT> {
            pub _M_off: root::std::streamoff,
            pub _M_state: _StateT,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
        }
        pub type streampos = root::std::fpos<root::__mbstate_t>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type __c_locale = root::__locale_t;
        pub type ofstream = [u64; 64usize];
        #[repr(C)]
        pub struct __cow_string {
            pub __bindgen_anon_1: root::std::__cow_string__bindgen_ty_1,
        }
        #[repr(C)]
        #[derive(Copy, Clone)]
        pub union __cow_string__bindgen_ty_1 {
            pub _M_p: *const ::std::os::raw::c_char,
            pub _M_bytes: [::std::os::raw::c_char; 8usize],
            _bindgen_union_align: u64,
        }
        #[test]
        fn bindgen_test_layout___cow_string__bindgen_ty_1() {
            assert_eq!(
                ::std::mem::size_of::<__cow_string__bindgen_ty_1>(),
                8usize,
                concat!("Size of: ", stringify!(__cow_string__bindgen_ty_1))
            );
            assert_eq!(
                ::std::mem::align_of::<__cow_string__bindgen_ty_1>(),
                8usize,
                concat!("Alignment of ", stringify!(__cow_string__bindgen_ty_1))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_p as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__cow_string__bindgen_ty_1),
                    "::",
                    stringify!(_M_p)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<__cow_string__bindgen_ty_1>()))._M_bytes as *const _
                        as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(__cow_string__bindgen_ty_1),
                    "::",
                    stringify!(_M_bytes)
                )
            );
        }
        #[test]
        fn bindgen_test_layout___cow_string() {
            assert_eq!(
                ::std::mem::size_of::<__cow_string>(),
                8usize,
                concat!("Size of: ", stringify!(__cow_string))
            );
            assert_eq!(
                ::std::mem::align_of::<__cow_string>(),
                8usize,
                concat!("Alignment of ", stringify!(__cow_string))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12__cow_stringC1Ev"]
            pub fn __cow_string___cow_string(this: *mut root::std::__cow_string);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn __cow_string___cow_string1(
                this: *mut root::std::__cow_string,
                arg1: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12__cow_stringC1EPKcm"]
            pub fn __cow_string___cow_string2(
                this: *mut root::std::__cow_string,
                arg1: *const ::std::os::raw::c_char,
                arg2: root::std::size_t,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12__cow_stringC1ERKS_"]
            pub fn __cow_string___cow_string3(
                this: *mut root::std::__cow_string,
                arg1: *const root::std::__cow_string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12__cow_stringC1EOS_"]
            pub fn __cow_string___cow_string4(
                this: *mut root::std::__cow_string,
                arg1: *mut root::std::__cow_string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12__cow_stringD1Ev"]
            pub fn __cow_string___cow_string_destructor(this: *mut root::std::__cow_string);
        }
        impl __cow_string {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                __cow_string___cow_string(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                __cow_string___cow_string1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                arg1: *const ::std::os::raw::c_char,
                arg2: root::std::size_t,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                __cow_string___cow_string2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(arg1: *const root::std::__cow_string) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                __cow_string___cow_string3(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(arg1: *mut root::std::__cow_string) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                __cow_string___cow_string4(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                __cow_string___cow_string_destructor(self)
            }
        }
        #[repr(C)]
        pub struct runtime_error {
            pub _base: root::std::exception,
            pub _M_msg: root::std::__cow_string,
        }
        #[test]
        fn bindgen_test_layout_runtime_error() {
            assert_eq!(
                ::std::mem::size_of::<runtime_error>(),
                16usize,
                concat!("Size of: ", stringify!(runtime_error))
            );
            assert_eq!(
                ::std::mem::align_of::<runtime_error>(),
                8usize,
                concat!("Alignment of ", stringify!(runtime_error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<runtime_error>()))._M_msg as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(runtime_error),
                    "::",
                    stringify!(_M_msg)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn runtime_error_runtime_error(
                this: *mut root::std::runtime_error,
                __arg: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt13runtime_errorC1EPKc"]
            pub fn runtime_error_runtime_error1(
                this: *mut root::std::runtime_error,
                arg1: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt13runtime_errorC1ERKS_"]
            pub fn runtime_error_runtime_error2(
                this: *mut root::std::runtime_error,
                arg1: *const root::std::runtime_error,
            );
        }
        impl runtime_error {
            #[inline]
            pub unsafe fn new(__arg: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                runtime_error_runtime_error(__bindgen_tmp.as_mut_ptr(), __arg);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                runtime_error_runtime_error1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(arg1: *const root::std::runtime_error) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                runtime_error_runtime_error2(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt13runtime_errorD1Ev"]
            pub fn runtime_error_runtime_error_destructor(this: *mut root::std::runtime_error);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt13runtime_error4whatEv"]
            pub fn runtime_error_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map {
            pub _address: u8,
        }
        pub type map_key_type<_Key> = _Key;
        pub type map_mapped_type<_Tp> = _Tp;
        pub type map_value_type<_Key, _Tp> = root::std::pair<_Key, _Tp>;
        pub type map_key_compare<_Compare> = _Compare;
        pub type map_allocator_type<_Alloc> = _Alloc;
        pub type map__Alloc_value_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct map_value_compare<_Compare> {
            pub comp: _Compare,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Compare>>,
        }
        pub type map__Pair_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type map__Rep_type = root::std::_Rb_tree;
        pub type map__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type map_pointer = root::std::map__Alloc_traits;
        pub type map_const_pointer = root::std::map__Alloc_traits;
        pub type map_reference = root::std::map__Alloc_traits;
        pub type map_const_reference = root::std::map__Alloc_traits;
        pub type map_iterator = root::std::map__Rep_type;
        pub type map_const_iterator = root::std::map__Rep_type;
        pub type map_size_type = root::std::map__Rep_type;
        pub type map_difference_type = root::std::map__Rep_type;
        pub type map_reverse_iterator = root::std::map__Rep_type;
        pub type map_const_reverse_iterator = root::std::map__Rep_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct _Vector_base {
            pub _M_impl: root::std::_Vector_base__Vector_impl,
        }
        pub type _Vector_base__Tp_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type _Vector_base_pointer = root::__gnu_cxx::__alloc_traits;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Vector_base__Vector_impl {
            pub _M_start: root::std::_Vector_base_pointer,
            pub _M_finish: root::std::_Vector_base_pointer,
            pub _M_end_of_storage: root::std::_Vector_base_pointer,
        }
        pub type _Vector_base_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct vector {
            pub _address: u8,
        }
        pub type vector__Alloc_value_type = [u8; 0usize];
        pub type vector__Base = root::std::_Vector_base;
        pub type vector__Tp_alloc_type = root::std::vector__Base;
        pub type vector__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type vector_value_type<_Tp> = _Tp;
        pub type vector_pointer = root::std::vector__Base;
        pub type vector_const_pointer = root::std::vector__Alloc_traits;
        pub type vector_reference = root::std::vector__Alloc_traits;
        pub type vector_const_reference = root::std::vector__Alloc_traits;
        pub type vector_iterator = root::__gnu_cxx::__normal_iterator<root::std::vector_pointer>;
        pub type vector_const_iterator =
            root::__gnu_cxx::__normal_iterator<root::std::vector_const_pointer>;
        pub type vector_const_reverse_iterator =
            root::std::reverse_iterator<root::std::vector_const_iterator>;
        pub type vector_reverse_iterator = root::std::reverse_iterator<root::std::vector_iterator>;
        pub type vector_size_type = root::std::size_t;
        pub type vector_difference_type = isize;
        pub type vector_allocator_type<_Alloc> = _Alloc;
        #[repr(C)]
        #[derive(Debug)]
        pub struct set {
            pub _M_t: root::std::set__Rep_type,
        }
        pub type set__Alloc_value_type = [u8; 0usize];
        pub type set_key_type<_Key> = _Key;
        pub type set_value_type<_Key> = _Key;
        pub type set_key_compare<_Compare> = _Compare;
        pub type set_value_compare<_Compare> = _Compare;
        pub type set_allocator_type<_Alloc> = _Alloc;
        pub type set__Key_alloc_type = root::__gnu_cxx::__alloc_traits;
        pub type set__Rep_type = root::std::_Rb_tree;
        pub type set__Alloc_traits = root::__gnu_cxx::__alloc_traits;
        pub type set_pointer = root::std::set__Alloc_traits;
        pub type set_const_pointer = root::std::set__Alloc_traits;
        pub type set_reference = root::std::set__Alloc_traits;
        pub type set_const_reference = root::std::set__Alloc_traits;
        pub type set_iterator = root::std::set__Rep_type;
        pub type set_const_iterator = root::std::set__Rep_type;
        pub type set_reverse_iterator = root::std::set__Rep_type;
        pub type set_const_reverse_iterator = root::std::set__Rep_type;
        pub type set_size_type = root::std::set__Rep_type;
        pub type set_difference_type = root::std::set__Rep_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale {
            pub _M_impl: *mut root::std::locale__Impl,
        }
        pub type locale_category = ::std::os::raw::c_int;
        pub const locale__S_categories_size: root::std::locale__bindgen_ty_1 = 12;
        pub type locale__bindgen_ty_1 = u32;
        pub const locale_none: root::std::locale_category = 0;
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5ctypeE"]
            pub static locale_ctype: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale7numericE"]
            pub static locale_numeric: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale7collateE"]
            pub static locale_collate: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale4timeE"]
            pub static locale_time: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale8monetaryE"]
            pub static locale_monetary: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale8messagesE"]
            pub static locale_messages: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale3allE"]
            pub static locale_all: root::std::locale_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale10_S_classicE"]
            pub static mut locale__S_classic: *mut root::std::locale__Impl;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale9_S_globalE"]
            pub static mut locale__S_global: *mut root::std::locale__Impl;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale13_S_categoriesE"]
            pub static locale__S_categories: *const *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale7_S_onceE"]
            pub static mut locale__S_once: root::__gthread_once_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale17_S_twinned_facetsE"]
            pub static mut locale__S_twinned_facets: [*const root::std::locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale() {
            assert_eq!(
                ::std::mem::size_of::<locale>(),
                8usize,
                concat!("Size of: ", stringify!(locale))
            );
            assert_eq!(
                ::std::mem::align_of::<locale>(),
                8usize,
                concat!("Alignment of ", stringify!(locale))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale>()))._M_impl as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale),
                    "::",
                    stringify!(_M_impl)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt6locale4nameB5cxx11Ev"]
            pub fn locale_name(this: *const root::std::locale) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale6globalERKS_"]
            pub fn locale_global(__loc: *const root::std::locale) -> root::std::locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale7classicEv"]
            pub fn locale_classic() -> *const root::std::locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1Ev"]
            pub fn locale_locale(this: *mut root::std::locale);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1ERKS_"]
            pub fn locale_locale1(this: *mut root::std::locale, __other: *const root::std::locale);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1EPKc"]
            pub fn locale_locale2(this: *mut root::std::locale, __s: *const ::std::os::raw::c_char);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1ERKS_PKci"]
            pub fn locale_locale3(
                this: *mut root::std::locale,
                __base: *const root::std::locale,
                __s: *const ::std::os::raw::c_char,
                __cat: root::std::locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn locale_locale4(this: *mut root::std::locale, __s: *const root::std::string);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1ERKS_RKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEi"]
            pub fn locale_locale5(
                this: *mut root::std::locale,
                __base: *const root::std::locale,
                __s: *const root::std::string,
                __cat: root::std::locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeC1ERKS_S1_i"]
            pub fn locale_locale6(
                this: *mut root::std::locale,
                __base: *const root::std::locale,
                __add: *const root::std::locale,
                __cat: root::std::locale_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6localeD1Ev"]
            pub fn locale_locale_destructor(this: *mut root::std::locale);
        }
        impl locale {
            #[inline]
            pub unsafe fn name(&self) -> root::std::string {
                locale_name(self)
            }
            #[inline]
            pub unsafe fn global(__loc: *const root::std::locale) -> root::std::locale {
                locale_global(__loc)
            }
            #[inline]
            pub unsafe fn classic() -> *const root::std::locale {
                locale_classic()
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(__other: *const root::std::locale) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale1(__bindgen_tmp.as_mut_ptr(), __other);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(__s: *const ::std::os::raw::c_char) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale2(__bindgen_tmp.as_mut_ptr(), __s);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(
                __base: *const root::std::locale,
                __s: *const ::std::os::raw::c_char,
                __cat: root::std::locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale3(__bindgen_tmp.as_mut_ptr(), __base, __s, __cat);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(__s: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale4(__bindgen_tmp.as_mut_ptr(), __s);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new5(
                __base: *const root::std::locale,
                __s: *const root::std::string,
                __cat: root::std::locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale5(__bindgen_tmp.as_mut_ptr(), __base, __s, __cat);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new6(
                __base: *const root::std::locale,
                __add: *const root::std::locale,
                __cat: root::std::locale_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_locale6(__bindgen_tmp.as_mut_ptr(), __base, __add, __cat);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                locale_locale_destructor(self)
            }
        }
        #[repr(C)]
        pub struct locale_facet__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale_facet {
            pub vtable_: *const locale_facet__bindgen_vtable,
            pub _M_refcount: root::_Atomic_word,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct locale_facet___shim {
            _unused: [u8; 0],
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet11_S_c_localeE"]
            pub static mut locale_facet__S_c_locale: root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet9_S_c_nameE"]
            pub static locale_facet__S_c_name: [::std::os::raw::c_char; 2usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet7_S_onceE"]
            pub static mut locale_facet__S_once: root::__gthread_once_t;
        }
        #[test]
        fn bindgen_test_layout_locale_facet() {
            assert_eq!(
                ::std::mem::size_of::<locale_facet>(),
                16usize,
                concat!("Size of: ", stringify!(locale_facet))
            );
            assert_eq!(
                ::std::mem::align_of::<locale_facet>(),
                8usize,
                concat!("Alignment of ", stringify!(locale_facet))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale_facet>()))._M_refcount as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale_facet),
                    "::",
                    stringify!(_M_refcount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet18_S_create_c_localeERP15__locale_structPKcS2_"]
            pub fn locale_facet__S_create_c_locale(
                __cloc: *mut root::std::__c_locale,
                __s: *const ::std::os::raw::c_char,
                __old: root::std::__c_locale,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet17_S_clone_c_localeERP15__locale_struct"]
            pub fn locale_facet__S_clone_c_locale(
                __cloc: *mut root::std::__c_locale,
            ) -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet19_S_destroy_c_localeERP15__locale_struct"]
            pub fn locale_facet__S_destroy_c_locale(__cloc: *mut root::std::__c_locale);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet20_S_lc_ctype_c_localeEP15__locale_structPKc"]
            pub fn locale_facet__S_lc_ctype_c_locale(
                __cloc: root::std::__c_locale,
                __s: *const ::std::os::raw::c_char,
            ) -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet15_S_get_c_localeEv"]
            pub fn locale_facet__S_get_c_locale() -> root::std::__c_locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facet13_S_get_c_nameEv"]
            pub fn locale_facet__S_get_c_name() -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facetC1Em"]
            pub fn locale_facet_facet(
                this: *mut root::std::locale_facet,
                __refs: root::std::size_t,
            );
        }
        impl locale_facet {
            #[inline]
            pub unsafe fn _S_create_c_locale(
                __cloc: *mut root::std::__c_locale,
                __s: *const ::std::os::raw::c_char,
                __old: root::std::__c_locale,
            ) {
                locale_facet__S_create_c_locale(__cloc, __s, __old)
            }
            #[inline]
            pub unsafe fn _S_clone_c_locale(
                __cloc: *mut root::std::__c_locale,
            ) -> root::std::__c_locale {
                locale_facet__S_clone_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_destroy_c_locale(__cloc: *mut root::std::__c_locale) {
                locale_facet__S_destroy_c_locale(__cloc)
            }
            #[inline]
            pub unsafe fn _S_lc_ctype_c_locale(
                __cloc: root::std::__c_locale,
                __s: *const ::std::os::raw::c_char,
            ) -> root::std::__c_locale {
                locale_facet__S_lc_ctype_c_locale(__cloc, __s)
            }
            #[inline]
            pub unsafe fn _S_get_c_locale() -> root::std::__c_locale {
                locale_facet__S_get_c_locale()
            }
            #[inline]
            pub unsafe fn _S_get_c_name() -> *const ::std::os::raw::c_char {
                locale_facet__S_get_c_name()
            }
            #[inline]
            pub unsafe fn new(__refs: root::std::size_t) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_facet_facet(__bindgen_tmp.as_mut_ptr(), __refs);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5facetD1Ev"]
            pub fn locale_facet_facet_destructor(this: *mut root::std::locale_facet);
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct locale_id {
            pub _M_index: root::std::size_t,
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale2id11_S_refcountE"]
            pub static mut locale_id__S_refcount: root::_Atomic_word;
        }
        #[test]
        fn bindgen_test_layout_locale_id() {
            assert_eq!(
                ::std::mem::size_of::<locale_id>(),
                8usize,
                concat!("Size of: ", stringify!(locale_id))
            );
            assert_eq!(
                ::std::mem::align_of::<locale_id>(),
                8usize,
                concat!("Alignment of ", stringify!(locale_id))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale_id>()))._M_index as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale_id),
                    "::",
                    stringify!(_M_index)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt6locale2id5_M_idEv"]
            pub fn locale_id__M_id(this: *const root::std::locale_id) -> root::std::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale2idC1Ev"]
            pub fn locale_id_id(this: *mut root::std::locale_id);
        }
        impl locale_id {
            #[inline]
            pub unsafe fn _M_id(&self) -> root::std::size_t {
                locale_id__M_id(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                locale_id_id(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct locale__Impl {
            pub _M_refcount: root::_Atomic_word,
            pub _M_facets: *mut *const root::std::locale_facet,
            pub _M_facets_size: root::std::size_t,
            pub _M_caches: *mut *const root::std::locale_facet,
            pub _M_names: *mut *mut ::std::os::raw::c_char,
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl11_S_id_ctypeE"]
            pub static mut locale__Impl__S_id_ctype: [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_numericE"]
            pub static mut locale__Impl__S_id_numeric: [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl13_S_id_collateE"]
            pub static mut locale__Impl__S_id_collate: [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl10_S_id_timeE"]
            pub static mut locale__Impl__S_id_time: [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_monetaryE"]
            pub static mut locale__Impl__S_id_monetary: [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl14_S_id_messagesE"]
            pub static mut locale__Impl__S_id_messages: [*const root::std::locale_id; 0usize];
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt6locale5_Impl19_S_facet_categoriesE"]
            pub static mut locale__Impl__S_facet_categories:
                [*const *const root::std::locale_id; 0usize];
        }
        #[test]
        fn bindgen_test_layout_locale__Impl() {
            assert_eq!(
                ::std::mem::size_of::<locale__Impl>(),
                40usize,
                concat!("Size of: ", stringify!(locale__Impl))
            );
            assert_eq!(
                ::std::mem::align_of::<locale__Impl>(),
                8usize,
                concat!("Alignment of ", stringify!(locale__Impl))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale__Impl>()))._M_refcount as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_refcount)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_facets as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_facets)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<locale__Impl>()))._M_facets_size as *const _ as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_facets_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_caches as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_caches)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<locale__Impl>()))._M_names as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(locale__Impl),
                    "::",
                    stringify!(_M_names)
                )
            );
        }
        #[repr(C)]
        pub struct error_category__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct error_category {
            pub vtable_: *const error_category__bindgen_vtable,
        }
        #[test]
        fn bindgen_test_layout_error_category() {
            assert_eq!(
                ::std::mem::size_of::<error_category>(),
                8usize,
                concat!("Size of: ", stringify!(error_category))
            );
            assert_eq!(
                ::std::mem::align_of::<error_category>(),
                8usize,
                concat!("Alignment of ", stringify!(error_category))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt3_V214error_categoryC2Ev"]
            pub fn error_category_error_category(this: *mut root::std::error_category);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt3_V214error_categoryC2ERKS0_"]
            pub fn error_category_error_category1(
                this: *mut root::std::error_category,
                arg1: *const root::std::error_category,
            );
        }
        impl error_category {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                error_category_error_category(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::std::error_category) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                error_category_error_category1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
            pub fn error_category_error_category_destructor(this: *mut root::std::error_category);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
            pub fn error_category_default_error_condition(
                this: *mut ::std::os::raw::c_void,
                __i: ::std::os::raw::c_int,
            ) -> root::std::error_condition;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
            pub fn error_category_equivalent(
                this: *mut ::std::os::raw::c_void,
                __i: ::std::os::raw::c_int,
                __cond: *const root::std::error_condition,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
            pub fn error_category_equivalent1(
                this: *mut ::std::os::raw::c_void,
                __code: *const root::std::error_code,
                __i: ::std::os::raw::c_int,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct error_code {
            pub _M_value: ::std::os::raw::c_int,
            pub _M_cat: *const root::std::error_category,
        }
        #[test]
        fn bindgen_test_layout_error_code() {
            assert_eq!(
                ::std::mem::size_of::<error_code>(),
                16usize,
                concat!("Size of: ", stringify!(error_code))
            );
            assert_eq!(
                ::std::mem::align_of::<error_code>(),
                8usize,
                concat!("Alignment of ", stringify!(error_code))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_code>()))._M_value as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_code),
                    "::",
                    stringify!(_M_value)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_code>()))._M_cat as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_code),
                    "::",
                    stringify!(_M_cat)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10error_code6assignEiRKNSt3_V214error_categoryE"]
            pub fn error_code_assign(
                this: *mut root::std::error_code,
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10error_code5clearEv"]
            pub fn error_code_clear(this: *mut root::std::error_code);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt10error_code5valueEv"]
            pub fn error_code_value(this: *const root::std::error_code) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt10error_code8categoryEv"]
            pub fn error_code_category(
                this: *const root::std::error_code,
            ) -> *const root::std::error_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
            pub fn error_code_default_error_condition(
                this: *const root::std::error_code,
            ) -> root::std::error_condition;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt10error_code7messageB5cxx11Ev"]
            pub fn error_code_message(this: *const root::std::error_code) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10error_codeC1Ev"]
            pub fn error_code_error_code(this: *mut root::std::error_code);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10error_codeC1EiRKNSt3_V214error_categoryE"]
            pub fn error_code_error_code1(
                this: *mut root::std::error_code,
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            );
        }
        impl error_code {
            #[inline]
            pub unsafe fn assign(
                &mut self,
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            ) {
                error_code_assign(self, __v, __cat)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                error_code_clear(self)
            }
            #[inline]
            pub unsafe fn value(&self) -> ::std::os::raw::c_int {
                error_code_value(self)
            }
            #[inline]
            pub unsafe fn category(&self) -> *const root::std::error_category {
                error_code_category(self)
            }
            #[inline]
            pub unsafe fn default_error_condition(&self) -> root::std::error_condition {
                error_code_default_error_condition(self)
            }
            #[inline]
            pub unsafe fn message(&self) -> root::std::string {
                error_code_message(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                error_code_error_code(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                error_code_error_code1(__bindgen_tmp.as_mut_ptr(), __v, __cat);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct error_condition {
            pub _M_value: ::std::os::raw::c_int,
            pub _M_cat: *const root::std::error_category,
        }
        #[test]
        fn bindgen_test_layout_error_condition() {
            assert_eq!(
                ::std::mem::size_of::<error_condition>(),
                16usize,
                concat!("Size of: ", stringify!(error_condition))
            );
            assert_eq!(
                ::std::mem::align_of::<error_condition>(),
                8usize,
                concat!("Alignment of ", stringify!(error_condition))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<error_condition>()))._M_value as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_condition),
                    "::",
                    stringify!(_M_value)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<error_condition>()))._M_cat as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(error_condition),
                    "::",
                    stringify!(_M_cat)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15error_condition6assignEiRKNSt3_V214error_categoryE"]
            pub fn error_condition_assign(
                this: *mut root::std::error_condition,
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15error_condition5clearEv"]
            pub fn error_condition_clear(this: *mut root::std::error_condition);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt15error_condition5valueEv"]
            pub fn error_condition_value(
                this: *const root::std::error_condition,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt15error_condition8categoryEv"]
            pub fn error_condition_category(
                this: *const root::std::error_condition,
            ) -> *const root::std::error_category;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt15error_condition7messageB5cxx11Ev"]
            pub fn error_condition_message(
                this: *const root::std::error_condition,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15error_conditionC1Ev"]
            pub fn error_condition_error_condition(this: *mut root::std::error_condition);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt15error_conditionC1EiRKNSt3_V214error_categoryE"]
            pub fn error_condition_error_condition1(
                this: *mut root::std::error_condition,
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            );
        }
        impl error_condition {
            #[inline]
            pub unsafe fn assign(
                &mut self,
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            ) {
                error_condition_assign(self, __v, __cat)
            }
            #[inline]
            pub unsafe fn clear(&mut self) {
                error_condition_clear(self)
            }
            #[inline]
            pub unsafe fn value(&self) -> ::std::os::raw::c_int {
                error_condition_value(self)
            }
            #[inline]
            pub unsafe fn category(&self) -> *const root::std::error_category {
                error_condition_category(self)
            }
            #[inline]
            pub unsafe fn message(&self) -> root::std::string {
                error_condition_message(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                error_condition_error_condition(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                __v: ::std::os::raw::c_int,
                __cat: *const root::std::error_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                error_condition_error_condition1(__bindgen_tmp.as_mut_ptr(), __v, __cat);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct system_error {
            pub _base: root::std::runtime_error,
            pub _M_code: root::std::error_code,
        }
        #[test]
        fn bindgen_test_layout_system_error() {
            assert_eq!(
                ::std::mem::size_of::<system_error>(),
                32usize,
                concat!("Size of: ", stringify!(system_error))
            );
            assert_eq!(
                ::std::mem::align_of::<system_error>(),
                8usize,
                concat!("Alignment of ", stringify!(system_error))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<system_error>()))._M_code as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(system_error),
                    "::",
                    stringify!(_M_code)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt12system_error4codeEv"]
            pub fn system_error_code(
                this: *const root::std::system_error,
            ) -> *const root::std::error_code;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorC1ESt10error_code"]
            pub fn system_error_system_error(
                this: *mut root::std::system_error,
                __ec: root::std::error_code,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorC1ESt10error_codeRKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn system_error_system_error1(
                this: *mut root::std::system_error,
                __ec: root::std::error_code,
                __what: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorC1ESt10error_codePKc"]
            pub fn system_error_system_error2(
                this: *mut root::std::system_error,
                __ec: root::std::error_code,
                __what: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorC1EiRKNSt3_V214error_categoryEPKc"]
            pub fn system_error_system_error3(
                this: *mut root::std::system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const root::std::error_category,
                __what: *const ::std::os::raw::c_char,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorC1EiRKNSt3_V214error_categoryE"]
            pub fn system_error_system_error4(
                this: *mut root::std::system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const root::std::error_category,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorC1EiRKNSt3_V214error_categoryERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn system_error_system_error5(
                this: *mut root::std::system_error,
                __v: ::std::os::raw::c_int,
                __ecat: *const root::std::error_category,
                __what: *const root::std::string,
            );
        }
        impl system_error {
            #[inline]
            pub unsafe fn code(&self) -> *const root::std::error_code {
                system_error_code(self)
            }
            #[inline]
            pub unsafe fn new(__ec: root::std::error_code) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                system_error_system_error(__bindgen_tmp.as_mut_ptr(), __ec);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                __ec: root::std::error_code,
                __what: *const root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                system_error_system_error1(__bindgen_tmp.as_mut_ptr(), __ec, __what);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                __ec: root::std::error_code,
                __what: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                system_error_system_error2(__bindgen_tmp.as_mut_ptr(), __ec, __what);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(
                __v: ::std::os::raw::c_int,
                __ecat: *const root::std::error_category,
                __what: *const ::std::os::raw::c_char,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                system_error_system_error3(__bindgen_tmp.as_mut_ptr(), __v, __ecat, __what);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(
                __v: ::std::os::raw::c_int,
                __ecat: *const root::std::error_category,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                system_error_system_error4(__bindgen_tmp.as_mut_ptr(), __v, __ecat);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new5(
                __v: ::std::os::raw::c_int,
                __ecat: *const root::std::error_category,
                __what: *const root::std::string,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                system_error_system_error5(__bindgen_tmp.as_mut_ptr(), __v, __ecat, __what);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt12system_errorD1Ev"]
            pub fn system_error_system_error_destructor(this: *mut root::std::system_error);
        }
        pub const _Ios_Fmtflags__S_boolalpha: root::std::_Ios_Fmtflags = 1;
        pub const _Ios_Fmtflags__S_dec: root::std::_Ios_Fmtflags = 2;
        pub const _Ios_Fmtflags__S_fixed: root::std::_Ios_Fmtflags = 4;
        pub const _Ios_Fmtflags__S_hex: root::std::_Ios_Fmtflags = 8;
        pub const _Ios_Fmtflags__S_internal: root::std::_Ios_Fmtflags = 16;
        pub const _Ios_Fmtflags__S_left: root::std::_Ios_Fmtflags = 32;
        pub const _Ios_Fmtflags__S_oct: root::std::_Ios_Fmtflags = 64;
        pub const _Ios_Fmtflags__S_right: root::std::_Ios_Fmtflags = 128;
        pub const _Ios_Fmtflags__S_scientific: root::std::_Ios_Fmtflags = 256;
        pub const _Ios_Fmtflags__S_showbase: root::std::_Ios_Fmtflags = 512;
        pub const _Ios_Fmtflags__S_showpoint: root::std::_Ios_Fmtflags = 1024;
        pub const _Ios_Fmtflags__S_showpos: root::std::_Ios_Fmtflags = 2048;
        pub const _Ios_Fmtflags__S_skipws: root::std::_Ios_Fmtflags = 4096;
        pub const _Ios_Fmtflags__S_unitbuf: root::std::_Ios_Fmtflags = 8192;
        pub const _Ios_Fmtflags__S_uppercase: root::std::_Ios_Fmtflags = 16384;
        pub const _Ios_Fmtflags__S_adjustfield: root::std::_Ios_Fmtflags = 176;
        pub const _Ios_Fmtflags__S_basefield: root::std::_Ios_Fmtflags = 74;
        pub const _Ios_Fmtflags__S_floatfield: root::std::_Ios_Fmtflags = 260;
        pub const _Ios_Fmtflags__S_ios_fmtflags_end: root::std::_Ios_Fmtflags = 65536;
        pub const _Ios_Fmtflags__S_ios_fmtflags_max: root::std::_Ios_Fmtflags = 2147483647;
        pub const _Ios_Fmtflags__S_ios_fmtflags_min: root::std::_Ios_Fmtflags = -2147483648;
        pub type _Ios_Fmtflags = i32;
        pub const _Ios_Openmode__S_app: root::std::_Ios_Openmode = 1;
        pub const _Ios_Openmode__S_ate: root::std::_Ios_Openmode = 2;
        pub const _Ios_Openmode__S_bin: root::std::_Ios_Openmode = 4;
        pub const _Ios_Openmode__S_in: root::std::_Ios_Openmode = 8;
        pub const _Ios_Openmode__S_out: root::std::_Ios_Openmode = 16;
        pub const _Ios_Openmode__S_trunc: root::std::_Ios_Openmode = 32;
        pub const _Ios_Openmode__S_ios_openmode_end: root::std::_Ios_Openmode = 65536;
        pub const _Ios_Openmode__S_ios_openmode_max: root::std::_Ios_Openmode = 2147483647;
        pub const _Ios_Openmode__S_ios_openmode_min: root::std::_Ios_Openmode = -2147483648;
        pub type _Ios_Openmode = i32;
        pub const _Ios_Iostate__S_goodbit: root::std::_Ios_Iostate = 0;
        pub const _Ios_Iostate__S_badbit: root::std::_Ios_Iostate = 1;
        pub const _Ios_Iostate__S_eofbit: root::std::_Ios_Iostate = 2;
        pub const _Ios_Iostate__S_failbit: root::std::_Ios_Iostate = 4;
        pub const _Ios_Iostate__S_ios_iostate_end: root::std::_Ios_Iostate = 65536;
        pub const _Ios_Iostate__S_ios_iostate_max: root::std::_Ios_Iostate = 2147483647;
        pub const _Ios_Iostate__S_ios_iostate_min: root::std::_Ios_Iostate = -2147483648;
        pub type _Ios_Iostate = i32;
        pub const _Ios_Seekdir__S_beg: root::std::_Ios_Seekdir = 0;
        pub const _Ios_Seekdir__S_cur: root::std::_Ios_Seekdir = 1;
        pub const _Ios_Seekdir__S_end: root::std::_Ios_Seekdir = 2;
        pub const _Ios_Seekdir__S_ios_seekdir_end: root::std::_Ios_Seekdir = 65536;
        pub type _Ios_Seekdir = u32;
        #[repr(C)]
        pub struct ios_base__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base {
            pub vtable_: *const ios_base__bindgen_vtable,
            pub _M_precision: root::std::streamsize,
            pub _M_width: root::std::streamsize,
            pub _M_flags: root::std::ios_base_fmtflags,
            pub _M_exception: root::std::ios_base_iostate,
            pub _M_streambuf_state: root::std::ios_base_iostate,
            pub _M_callbacks: *mut root::std::ios_base__Callback_list,
            pub _M_word_zero: root::std::ios_base__Words,
            pub _M_local_word: [root::std::ios_base__Words; 8usize],
            pub _M_word_size: ::std::os::raw::c_int,
            pub _M_word: *mut root::std::ios_base__Words,
            pub _M_ios_locale: root::std::locale,
        }
        #[repr(C)]
        pub struct ios_base_failure {
            pub _base: root::std::system_error,
        }
        #[test]
        fn bindgen_test_layout_ios_base_failure() {
            assert_eq!(
                ::std::mem::size_of::<ios_base_failure>(),
                32usize,
                concat!("Size of: ", stringify!(ios_base_failure))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base_failure>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base_failure))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn ios_base_failure_failure(
                this: *mut root::std::ios_base_failure,
                __str: *const root::std::string,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERKSt10error_code"]
            pub fn ios_base_failure_failure1(
                this: *mut root::std::ios_base_failure,
                arg1: *const root::std::string,
                arg2: *const root::std::error_code,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11C1EPKcRKSt10error_code"]
            pub fn ios_base_failure_failure2(
                this: *mut root::std::ios_base_failure,
                arg1: *const ::std::os::raw::c_char,
                arg2: *const root::std::error_code,
            );
        }
        impl ios_base_failure {
            #[inline]
            pub unsafe fn new(__str: *const root::std::string) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base_failure_failure(__bindgen_tmp.as_mut_ptr(), __str);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                arg1: *const root::std::string,
                arg2: *const root::std::error_code,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base_failure_failure1(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                arg1: *const ::std::os::raw::c_char,
                arg2: *const root::std::error_code,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base_failure_failure2(__bindgen_tmp.as_mut_ptr(), arg1, arg2);
                __bindgen_tmp.assume_init()
            }
        }
        pub use self::super::super::root::std::_Ios_Fmtflags as ios_base_fmtflags;
        pub use self::super::super::root::std::_Ios_Iostate as ios_base_iostate;
        pub use self::super::super::root::std::_Ios_Openmode as ios_base_openmode;
        pub use self::super::super::root::std::_Ios_Seekdir as ios_base_seekdir;
        pub type ios_base_io_state = ::std::os::raw::c_int;
        pub type ios_base_open_mode = ::std::os::raw::c_int;
        pub type ios_base_seek_dir = ::std::os::raw::c_int;
        pub type ios_base_streampos = root::std::streampos;
        pub type ios_base_streamoff = root::std::streamoff;
        pub const ios_base_event_erase_event: root::std::ios_base_event = 0;
        pub const ios_base_event_imbue_event: root::std::ios_base_event = 1;
        pub const ios_base_event_copyfmt_event: root::std::ios_base_event = 2;
        pub type ios_base_event = u32;
        pub type ios_base_event_callback = ::std::option::Option<
            unsafe extern "C" fn(
                __e: root::std::ios_base_event,
                __b: *mut root::std::ios_base,
                __i: ::std::os::raw::c_int,
            ),
        >;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ios_base__Callback_list {
            pub _M_next: *mut root::std::ios_base__Callback_list,
            pub _M_fn: root::std::ios_base_event_callback,
            pub _M_index: ::std::os::raw::c_int,
            pub _M_refcount: root::_Atomic_word,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Callback_list() {
            assert_eq!(
                ::std::mem::size_of::<ios_base__Callback_list>(),
                24usize,
                concat!("Size of: ", stringify!(ios_base__Callback_list))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base__Callback_list>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base__Callback_list))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_next as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_next)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_fn as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_fn)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_index as *const _
                        as usize
                },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_index)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Callback_list>()))._M_refcount as *const _
                        as usize
                },
                20usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Callback_list),
                    "::",
                    stringify!(_M_refcount)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base14_Callback_list16_M_add_referenceEv"]
            pub fn ios_base__Callback_list__M_add_reference(
                this: *mut root::std::ios_base__Callback_list,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base14_Callback_list19_M_remove_referenceEv"]
            pub fn ios_base__Callback_list__M_remove_reference(
                this: *mut root::std::ios_base__Callback_list,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base14_Callback_listC1EPFvNS_5eventERS_iEiPS0_"]
            pub fn ios_base__Callback_list__Callback_list(
                this: *mut root::std::ios_base__Callback_list,
                __fn: root::std::ios_base_event_callback,
                __index: ::std::os::raw::c_int,
                __cb: *mut root::std::ios_base__Callback_list,
            );
        }
        impl ios_base__Callback_list {
            #[inline]
            pub unsafe fn _M_add_reference(&mut self) {
                ios_base__Callback_list__M_add_reference(self)
            }
            #[inline]
            pub unsafe fn _M_remove_reference(&mut self) -> ::std::os::raw::c_int {
                ios_base__Callback_list__M_remove_reference(self)
            }
            #[inline]
            pub unsafe fn new(
                __fn: root::std::ios_base_event_callback,
                __index: ::std::os::raw::c_int,
                __cb: *mut root::std::ios_base__Callback_list,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base__Callback_list__Callback_list(
                    __bindgen_tmp.as_mut_ptr(),
                    __fn,
                    __index,
                    __cb,
                );
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ios_base__Words {
            pub _M_pword: *mut ::std::os::raw::c_void,
            pub _M_iword: ::std::os::raw::c_long,
        }
        #[test]
        fn bindgen_test_layout_ios_base__Words() {
            assert_eq!(
                ::std::mem::size_of::<ios_base__Words>(),
                16usize,
                concat!("Size of: ", stringify!(ios_base__Words))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base__Words>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base__Words))
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Words>()))._M_pword as *const _ as usize
                },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Words),
                    "::",
                    stringify!(_M_pword)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base__Words>()))._M_iword as *const _ as usize
                },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base__Words),
                    "::",
                    stringify!(_M_iword)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6_WordsC1Ev"]
            pub fn ios_base__Words__Words(this: *mut root::std::ios_base__Words);
        }
        impl ios_base__Words {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base__Words__Words(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        pub const ios_base__S_local_word_size: root::std::ios_base__bindgen_ty_1 = 8;
        pub type ios_base__bindgen_ty_1 = u32;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ios_base_Init {
            pub _address: u8,
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4Init11_S_refcountE"]
            pub static mut ios_base_Init__S_refcount: root::_Atomic_word;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4Init20_S_synced_with_stdioE"]
            pub static mut ios_base_Init__S_synced_with_stdio: bool;
        }
        #[test]
        fn bindgen_test_layout_ios_base_Init() {
            assert_eq!(
                ::std::mem::size_of::<ios_base_Init>(),
                1usize,
                concat!("Size of: ", stringify!(ios_base_Init))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base_Init>(),
                1usize,
                concat!("Alignment of ", stringify!(ios_base_Init))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4InitC1Ev"]
            pub fn ios_base_Init_Init(this: *mut root::std::ios_base_Init);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4InitD1Ev"]
            pub fn ios_base_Init_Init_destructor(this: *mut root::std::ios_base_Init);
        }
        impl ios_base_Init {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base_Init_Init(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ios_base_Init_Init_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base9boolalphaE"]
            pub static ios_base_boolalpha: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3decE"]
            pub static ios_base_dec: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5fixedE"]
            pub static ios_base_fixed: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3hexE"]
            pub static ios_base_hex: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base8internalE"]
            pub static ios_base_internal: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4leftE"]
            pub static ios_base_left: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3octE"]
            pub static ios_base_oct: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5rightE"]
            pub static ios_base_right: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base10scientificE"]
            pub static ios_base_scientific: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base8showbaseE"]
            pub static ios_base_showbase: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base9showpointE"]
            pub static ios_base_showpoint: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7showposE"]
            pub static ios_base_showpos: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6skipwsE"]
            pub static ios_base_skipws: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7unitbufE"]
            pub static ios_base_unitbuf: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base9uppercaseE"]
            pub static ios_base_uppercase: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base11adjustfieldE"]
            pub static ios_base_adjustfield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base9basefieldE"]
            pub static ios_base_basefield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base10floatfieldE"]
            pub static ios_base_floatfield: root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6badbitE"]
            pub static ios_base_badbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6eofbitE"]
            pub static ios_base_eofbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7failbitE"]
            pub static ios_base_failbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7goodbitE"]
            pub static ios_base_goodbit: root::std::ios_base_iostate;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3appE"]
            pub static ios_base_app: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3ateE"]
            pub static ios_base_ate: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6binaryE"]
            pub static ios_base_binary: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base2inE"]
            pub static ios_base_in: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3outE"]
            pub static ios_base_out: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5truncE"]
            pub static ios_base_trunc: root::std::ios_base_openmode;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3begE"]
            pub static ios_base_beg: root::std::ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3curE"]
            pub static ios_base_cur: root::std::ios_base_seekdir;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base3endE"]
            pub static ios_base_end: root::std::ios_base_seekdir;
        }
        #[test]
        fn bindgen_test_layout_ios_base() {
            assert_eq!(
                ::std::mem::size_of::<ios_base>(),
                216usize,
                concat!("Size of: ", stringify!(ios_base))
            );
            assert_eq!(
                ::std::mem::align_of::<ios_base>(),
                8usize,
                concat!("Alignment of ", stringify!(ios_base))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_precision as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_precision)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_width as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_width)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_flags as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_flags)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_exception as *const _ as usize },
                28usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_exception)
                )
            );
            assert_eq!(
                unsafe {
                    &(*(::std::ptr::null::<ios_base>()))._M_streambuf_state as *const _ as usize
                },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_streambuf_state)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_callbacks as *const _ as usize },
                40usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_callbacks)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_zero as *const _ as usize },
                48usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word_zero)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_local_word as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_local_word)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word_size as *const _ as usize },
                192usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word_size)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_word as *const _ as usize },
                200usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_word)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<ios_base>()))._M_ios_locale as *const _ as usize },
                208usize,
                concat!(
                    "Offset of field: ",
                    stringify!(ios_base),
                    "::",
                    stringify!(_M_ios_locale)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base17register_callbackEPFvNS_5eventERS_iEi"]
            pub fn ios_base_register_callback(
                this: *mut root::std::ios_base,
                __fn: root::std::ios_base_event_callback,
                __index: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base17_M_call_callbacksENS_5eventE"]
            pub fn ios_base__M_call_callbacks(
                this: *mut root::std::ios_base,
                __ev: root::std::ios_base_event,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base20_M_dispose_callbacksEv"]
            pub fn ios_base__M_dispose_callbacks(this: *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base13_M_grow_wordsEib"]
            pub fn ios_base__M_grow_words(
                this: *mut root::std::ios_base,
                __index: ::std::os::raw::c_int,
                __iword: bool,
            ) -> *mut root::std::ios_base__Words;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7_M_initEv"]
            pub fn ios_base__M_init(this: *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt8ios_base5flagsEv"]
            pub fn ios_base_flags(this: *const root::std::ios_base)
                -> root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5flagsESt13_Ios_Fmtflags"]
            pub fn ios_base_flags1(
                this: *mut root::std::ios_base,
                __fmtfl: root::std::ios_base_fmtflags,
            ) -> root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4setfESt13_Ios_Fmtflags"]
            pub fn ios_base_setf(
                this: *mut root::std::ios_base,
                __fmtfl: root::std::ios_base_fmtflags,
            ) -> root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base4setfESt13_Ios_FmtflagsS0_"]
            pub fn ios_base_setf1(
                this: *mut root::std::ios_base,
                __fmtfl: root::std::ios_base_fmtflags,
                __mask: root::std::ios_base_fmtflags,
            ) -> root::std::ios_base_fmtflags;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6unsetfESt13_Ios_Fmtflags"]
            pub fn ios_base_unsetf(
                this: *mut root::std::ios_base,
                __mask: root::std::ios_base_fmtflags,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt8ios_base9precisionEv"]
            pub fn ios_base_precision(this: *const root::std::ios_base) -> root::std::streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base9precisionEl"]
            pub fn ios_base_precision1(
                this: *mut root::std::ios_base,
                __prec: root::std::streamsize,
            ) -> root::std::streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt8ios_base5widthEv"]
            pub fn ios_base_width(this: *const root::std::ios_base) -> root::std::streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5widthEl"]
            pub fn ios_base_width1(
                this: *mut root::std::ios_base,
                __wide: root::std::streamsize,
            ) -> root::std::streamsize;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base15sync_with_stdioEb"]
            pub fn ios_base_sync_with_stdio(__sync: bool) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5imbueERKSt6locale"]
            pub fn ios_base_imbue(
                this: *mut root::std::ios_base,
                __loc: *const root::std::locale,
            ) -> root::std::locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt8ios_base6getlocEv"]
            pub fn ios_base_getloc(this: *const root::std::ios_base) -> root::std::locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt8ios_base9_M_getlocEv"]
            pub fn ios_base__M_getloc(this: *const root::std::ios_base)
                -> *const root::std::locale;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base6xallocEv"]
            pub fn ios_base_xalloc() -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5iwordEi"]
            pub fn ios_base_iword(
                this: *mut root::std::ios_base,
                __ix: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_long;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base5pwordEi"]
            pub fn ios_base_pword(
                this: *mut root::std::ios_base,
                __ix: ::std::os::raw::c_int,
            ) -> *mut *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7_M_moveERS_"]
            pub fn ios_base__M_move(this: *mut root::std::ios_base, arg1: *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7_M_swapERS_"]
            pub fn ios_base__M_swap(
                this: *mut root::std::ios_base,
                __rhs: *mut root::std::ios_base,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_baseC1Ev"]
            pub fn ios_base_ios_base(this: *mut root::std::ios_base);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_baseC1ERKS_"]
            pub fn ios_base_ios_base1(
                this: *mut root::std::ios_base,
                arg1: *const root::std::ios_base,
            );
        }
        impl ios_base {
            #[inline]
            pub unsafe fn register_callback(
                &mut self,
                __fn: root::std::ios_base_event_callback,
                __index: ::std::os::raw::c_int,
            ) {
                ios_base_register_callback(self, __fn, __index)
            }
            #[inline]
            pub unsafe fn _M_call_callbacks(&mut self, __ev: root::std::ios_base_event) {
                ios_base__M_call_callbacks(self, __ev)
            }
            #[inline]
            pub unsafe fn _M_dispose_callbacks(&mut self) {
                ios_base__M_dispose_callbacks(self)
            }
            #[inline]
            pub unsafe fn _M_grow_words(
                &mut self,
                __index: ::std::os::raw::c_int,
                __iword: bool,
            ) -> *mut root::std::ios_base__Words {
                ios_base__M_grow_words(self, __index, __iword)
            }
            #[inline]
            pub unsafe fn _M_init(&mut self) {
                ios_base__M_init(self)
            }
            #[inline]
            pub unsafe fn flags(&self) -> root::std::ios_base_fmtflags {
                ios_base_flags(self)
            }
            #[inline]
            pub unsafe fn flags1(
                &mut self,
                __fmtfl: root::std::ios_base_fmtflags,
            ) -> root::std::ios_base_fmtflags {
                ios_base_flags1(self, __fmtfl)
            }
            #[inline]
            pub unsafe fn setf(
                &mut self,
                __fmtfl: root::std::ios_base_fmtflags,
            ) -> root::std::ios_base_fmtflags {
                ios_base_setf(self, __fmtfl)
            }
            #[inline]
            pub unsafe fn setf1(
                &mut self,
                __fmtfl: root::std::ios_base_fmtflags,
                __mask: root::std::ios_base_fmtflags,
            ) -> root::std::ios_base_fmtflags {
                ios_base_setf1(self, __fmtfl, __mask)
            }
            #[inline]
            pub unsafe fn unsetf(&mut self, __mask: root::std::ios_base_fmtflags) {
                ios_base_unsetf(self, __mask)
            }
            #[inline]
            pub unsafe fn precision(&self) -> root::std::streamsize {
                ios_base_precision(self)
            }
            #[inline]
            pub unsafe fn precision1(
                &mut self,
                __prec: root::std::streamsize,
            ) -> root::std::streamsize {
                ios_base_precision1(self, __prec)
            }
            #[inline]
            pub unsafe fn width(&self) -> root::std::streamsize {
                ios_base_width(self)
            }
            #[inline]
            pub unsafe fn width1(
                &mut self,
                __wide: root::std::streamsize,
            ) -> root::std::streamsize {
                ios_base_width1(self, __wide)
            }
            #[inline]
            pub unsafe fn sync_with_stdio(__sync: bool) -> bool {
                ios_base_sync_with_stdio(__sync)
            }
            #[inline]
            pub unsafe fn imbue(&mut self, __loc: *const root::std::locale) -> root::std::locale {
                ios_base_imbue(self, __loc)
            }
            #[inline]
            pub unsafe fn getloc(&self) -> root::std::locale {
                ios_base_getloc(self)
            }
            #[inline]
            pub unsafe fn _M_getloc(&self) -> *const root::std::locale {
                ios_base__M_getloc(self)
            }
            #[inline]
            pub unsafe fn xalloc() -> ::std::os::raw::c_int {
                ios_base_xalloc()
            }
            #[inline]
            pub unsafe fn iword(
                &mut self,
                __ix: ::std::os::raw::c_int,
            ) -> *mut ::std::os::raw::c_long {
                ios_base_iword(self, __ix)
            }
            #[inline]
            pub unsafe fn pword(
                &mut self,
                __ix: ::std::os::raw::c_int,
            ) -> *mut *mut ::std::os::raw::c_void {
                ios_base_pword(self, __ix)
            }
            #[inline]
            pub unsafe fn _M_move(&mut self, arg1: *mut root::std::ios_base) {
                ios_base__M_move(self, arg1)
            }
            #[inline]
            pub unsafe fn _M_swap(&mut self, __rhs: *mut root::std::ios_base) {
                ios_base__M_swap(self, __rhs)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base_ios_base(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(arg1: *const root::std::ios_base) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ios_base_ios_base1(__bindgen_tmp.as_mut_ptr(), arg1);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_base7failureB5cxx11D1Ev"]
            pub fn ios_base_failure_failure_destructor(this: *mut root::std::ios_base_failure);
        }
        extern "C" {
            #[link_name = "\u{1}_ZNKSt8ios_base7failureB5cxx114whatEv"]
            pub fn ios_base_failure_what(
                this: *mut ::std::os::raw::c_void,
            ) -> *const ::std::os::raw::c_char;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt8ios_baseD1Ev"]
            pub fn ios_base_ios_base_destructor(this: *mut root::std::ios_base);
        }
        #[repr(C)]
        pub struct basic_streambuf__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_streambuf<_CharT> {
            pub vtable_: *const basic_streambuf__bindgen_vtable,
            pub _M_in_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_in_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_in_end: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_beg: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_cur: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_out_end: *mut root::std::basic_streambuf_char_type<_CharT>,
            pub _M_buf_locale: root::std::locale,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_streambuf_char_type<_CharT> = _CharT;
        pub type basic_streambuf_traits_type<_Traits> = _Traits;
        pub type basic_streambuf_int_type = [u8; 0usize];
        pub type basic_streambuf_pos_type = [u8; 0usize];
        pub type basic_streambuf_off_type = [u8; 0usize];
        pub type basic_streambuf___streambuf_type<_CharT> =
            root::std::basic_streambuf<root::std::basic_streambuf_char_type<_CharT>>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ctype_base {
            pub _address: u8,
        }
        pub type ctype_base___to_type = *const ::std::os::raw::c_int;
        pub type ctype_base_mask = ::std::os::raw::c_ushort;
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5upperE"]
            pub static ctype_base_upper: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5lowerE"]
            pub static ctype_base_lower: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5alphaE"]
            pub static ctype_base_alpha: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5digitE"]
            pub static ctype_base_digit: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base6xdigitE"]
            pub static ctype_base_xdigit: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5spaceE"]
            pub static ctype_base_space: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5printE"]
            pub static ctype_base_print: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5graphE"]
            pub static ctype_base_graph: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5cntrlE"]
            pub static ctype_base_cntrl: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5punctE"]
            pub static ctype_base_punct: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5alnumE"]
            pub static ctype_base_alnum: root::std::ctype_base_mask;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNSt10ctype_base5blankE"]
            pub static ctype_base_blank: root::std::ctype_base_mask;
        }
        #[test]
        fn bindgen_test_layout_ctype_base() {
            assert_eq!(
                ::std::mem::size_of::<ctype_base>(),
                1usize,
                concat!("Size of: ", stringify!(ctype_base))
            );
            assert_eq!(
                ::std::mem::align_of::<ctype_base>(),
                1usize,
                concat!("Alignment of ", stringify!(ctype_base))
            );
        }
        #[repr(C)]
        pub struct istreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut root::std::istreambuf_iterator_streambuf_type<_CharT>,
            pub _M_c: root::std::istreambuf_iterator_int_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type istreambuf_iterator_char_type<_CharT> = _CharT;
        pub type istreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type istreambuf_iterator_int_type = [u8; 0usize];
        pub type istreambuf_iterator_streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
        pub type istreambuf_iterator_istream_type<_CharT> = root::std::basic_istream<_CharT>;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct ostreambuf_iterator<_CharT> {
            pub _M_sbuf: *mut root::std::ostreambuf_iterator_streambuf_type<_CharT>,
            pub _M_failed: bool,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type ostreambuf_iterator_char_type<_CharT> = _CharT;
        pub type ostreambuf_iterator_traits_type<_Traits> = _Traits;
        pub type ostreambuf_iterator_streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
        pub type ostreambuf_iterator_ostream_type = u8;
        #[repr(C)]
        #[derive(Debug)]
        pub struct __ctype_abstract_base {
            pub _base: root::std::locale_facet,
        }
        pub type __ctype_abstract_base_char_type<_CharT> = _CharT;
        #[repr(C)]
        #[derive(Debug)]
        pub struct ctype {
            pub _base: root::std::__ctype_abstract_base,
        }
        pub type ctype_char_type<_CharT> = _CharT;
        pub type ctype_mask = root::std::__ctype_abstract_base;
        #[repr(C)]
        #[derive(Debug)]
        pub struct num_get {
            pub _base: root::std::locale_facet,
        }
        pub type num_get_char_type<_CharT> = _CharT;
        pub type num_get_iter_type<_InIter> = _InIter;
        #[repr(C)]
        #[derive(Debug)]
        pub struct num_put {
            pub _base: root::std::locale_facet,
        }
        pub type num_put_char_type<_CharT> = _CharT;
        pub type num_put_iter_type<_OutIter> = _OutIter;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ios<_CharT> {
            pub _base: root::std::ios_base,
            pub _M_tie: *mut u8,
            pub _M_fill: root::std::basic_ios_char_type<_CharT>,
            pub _M_fill_init: bool,
            pub _M_streambuf: *mut root::std::basic_streambuf<_CharT>,
            pub _M_ctype: *const root::std::basic_ios___ctype_type,
            pub _M_num_put: *const root::std::basic_ios___num_put_type,
            pub _M_num_get: *const root::std::basic_ios___num_get_type,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_ios_char_type<_CharT> = _CharT;
        pub type basic_ios_int_type = [u8; 0usize];
        pub type basic_ios_pos_type = [u8; 0usize];
        pub type basic_ios_off_type = [u8; 0usize];
        pub type basic_ios_traits_type<_Traits> = _Traits;
        pub type basic_ios___ctype_type = root::std::ctype;
        pub type basic_ios___num_put_type = root::std::num_put;
        pub type basic_ios___num_get_type = root::std::num_get;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_ostream {}
        pub type basic_ostream_char_type<_CharT> = _CharT;
        pub type basic_ostream_int_type = [u8; 0usize];
        pub type basic_ostream_pos_type = [u8; 0usize];
        pub type basic_ostream_off_type = [u8; 0usize];
        pub type basic_ostream_traits_type<_Traits> = _Traits;
        pub type basic_ostream___streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
        pub type basic_ostream___ios_type<_CharT> = root::std::basic_ios<_CharT>;
        pub type basic_ostream___ostream_type = u8;
        pub type basic_ostream___num_put_type = root::std::num_put;
        pub type basic_ostream___ctype_type = root::std::ctype;
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_ostream_sentry {
            pub _M_ok: bool,
            pub _M_os: *mut u8,
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct basic_istream<_CharT> {
            pub _M_gcount: root::std::streamsize,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_istream_char_type<_CharT> = _CharT;
        pub type basic_istream_int_type = [u8; 0usize];
        pub type basic_istream_pos_type = [u8; 0usize];
        pub type basic_istream_off_type = [u8; 0usize];
        pub type basic_istream_traits_type<_Traits> = _Traits;
        pub type basic_istream___streambuf_type<_CharT> = root::std::basic_streambuf<_CharT>;
        pub type basic_istream___ios_type<_CharT> = root::std::basic_ios<_CharT>;
        pub type basic_istream___istream_type<_CharT> = root::std::basic_istream<_CharT>;
        pub type basic_istream___num_get_type = root::std::num_get;
        pub type basic_istream___ctype_type = root::std::ctype;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_istream_sentry {
            pub _M_ok: bool,
        }
        pub type basic_istream_sentry_traits_type = u8;
        pub type basic_istream_sentry___streambuf_type = u8;
        pub type basic_istream_sentry___istream_type = u8;
        pub type basic_istream_sentry___ctype_type = root::std::basic_istream___ctype_type;
        pub type basic_istream_sentry___int_type = [u8; 0usize];
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct codecvt_base {
            pub _address: u8,
        }
        pub const codecvt_base_result_ok: root::std::codecvt_base_result = 0;
        pub const codecvt_base_result_partial: root::std::codecvt_base_result = 1;
        pub const codecvt_base_result_error: root::std::codecvt_base_result = 2;
        pub const codecvt_base_result_noconv: root::std::codecvt_base_result = 3;
        pub type codecvt_base_result = u32;
        #[test]
        fn bindgen_test_layout_codecvt_base() {
            assert_eq!(
                ::std::mem::size_of::<codecvt_base>(),
                1usize,
                concat!("Size of: ", stringify!(codecvt_base))
            );
            assert_eq!(
                ::std::mem::align_of::<codecvt_base>(),
                1usize,
                concat!("Alignment of ", stringify!(codecvt_base))
            );
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct __codecvt_abstract_base {
            pub _base: root::std::locale_facet,
        }
        pub use self::super::super::root::std::codecvt_base_result as __codecvt_abstract_base_result;
        pub type __codecvt_abstract_base_intern_type<_InternT> = _InternT;
        pub type __codecvt_abstract_base_extern_type<_ExternT> = _ExternT;
        pub type __codecvt_abstract_base_state_type<_StateT> = _StateT;
        #[repr(C)]
        #[derive(Debug)]
        pub struct codecvt {
            pub _base: root::std::__codecvt_abstract_base,
            pub _M_c_locale_codecvt: root::std::__c_locale,
        }
        pub use self::super::super::root::std::codecvt_base_result as codecvt_result;
        pub type codecvt_intern_type<_InternT> = _InternT;
        pub type codecvt_extern_type<_ExternT> = _ExternT;
        pub type codecvt_state_type<_StateT> = _StateT;
        pub type __c_lock = root::__gthread_mutex_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __basic_file {
            pub _address: u8,
        }
        #[repr(C)]
        pub struct basic_filebuf<_CharT> {
            pub _base: root::std::basic_streambuf<_CharT>,
            pub _M_lock: root::std::__c_lock,
            pub _M_file: root::std::basic_filebuf___file_type,
            pub _M_mode: root::std::ios_base_openmode,
            pub _M_state_beg: root::std::basic_filebuf___state_type,
            pub _M_state_cur: root::std::basic_filebuf___state_type,
            pub _M_state_last: root::std::basic_filebuf___state_type,
            pub _M_buf: *mut root::std::basic_filebuf_char_type<_CharT>,
            pub _M_buf_size: root::std::size_t,
            pub _M_buf_allocated: bool,
            pub _M_reading: bool,
            pub _M_writing: bool,
            pub _M_pback: root::std::basic_filebuf_char_type<_CharT>,
            pub _M_pback_cur_save: *mut root::std::basic_filebuf_char_type<_CharT>,
            pub _M_pback_end_save: *mut root::std::basic_filebuf_char_type<_CharT>,
            pub _M_pback_init: bool,
            pub _M_codecvt: *const root::std::basic_filebuf___codecvt_type,
            pub _M_ext_buf: *mut ::std::os::raw::c_char,
            pub _M_ext_buf_size: root::std::streamsize,
            pub _M_ext_next: *const ::std::os::raw::c_char,
            pub _M_ext_end: *mut ::std::os::raw::c_char,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
        }
        pub type basic_filebuf___chk_state = root::std::__and_;
        pub type basic_filebuf_char_type<_CharT> = _CharT;
        pub type basic_filebuf_traits_type<_Traits> = _Traits;
        pub type basic_filebuf_int_type = [u8; 0usize];
        pub type basic_filebuf_pos_type = [u8; 0usize];
        pub type basic_filebuf_off_type = [u8; 0usize];
        pub type basic_filebuf___streambuf_type<_CharT> =
            root::std::basic_streambuf<root::std::basic_filebuf_char_type<_CharT>>;
        pub type basic_filebuf___filebuf_type<_CharT> =
            root::std::basic_filebuf<root::std::basic_filebuf_char_type<_CharT>>;
        pub type basic_filebuf___file_type = [u64; 2usize];
        pub type basic_filebuf___state_type = [u8; 0usize];
        pub type basic_filebuf___codecvt_type = root::std::codecvt;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct basic_ofstream {
            pub _address: u8,
        }
        pub type basic_ofstream_char_type<_CharT> = _CharT;
        pub type basic_ofstream_traits_type<_Traits> = _Traits;
        pub type basic_ofstream_int_type = [u8; 0usize];
        pub type basic_ofstream_pos_type = [u8; 0usize];
        pub type basic_ofstream_off_type = [u8; 0usize];
        pub type basic_ofstream___filebuf_type<_CharT> =
            root::std::basic_filebuf<root::std::basic_ofstream_char_type<_CharT>>;
        pub type basic_ofstream___ostream_type = u8;
    }
    pub mod __gnu_cxx {
        #[allow(unused_imports)]
        use self::super::super::root;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __normal_iterator<_Iterator> {
            pub _M_current: _Iterator,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
        }
        pub type __normal_iterator___traits_type = root::std::iterator_traits;
        pub type __normal_iterator_iterator_type<_Iterator> = _Iterator;
        pub type __normal_iterator_iterator_category =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_value_type = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_difference_type =
            root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_reference = root::__gnu_cxx::__normal_iterator___traits_type;
        pub type __normal_iterator_pointer = root::__gnu_cxx::__normal_iterator___traits_type;
        #[repr(C)]
        #[derive(Debug)]
        pub struct new_allocator {
            pub _address: u8,
        }
        pub type new_allocator_size_type = root::std::size_t;
        pub type new_allocator_difference_type = isize;
        pub type new_allocator_pointer<_Tp> = *mut _Tp;
        pub type new_allocator_const_pointer<_Tp> = *const _Tp;
        pub type new_allocator_reference<_Tp> = *mut _Tp;
        pub type new_allocator_const_reference<_Tp> = *const _Tp;
        pub type new_allocator_value_type<_Tp> = _Tp;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct new_allocator_rebind {
            pub _address: u8,
        }
        pub type new_allocator_rebind_other = root::__gnu_cxx::new_allocator;
        pub type new_allocator_propagate_on_container_move_assignment = root::std::true_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits {
            pub _address: u8,
        }
        pub type __alloc_traits_allocator_type<_Alloc> = _Alloc;
        pub type __alloc_traits__Base_type = root::std::allocator_traits;
        pub type __alloc_traits_value_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_const_pointer = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_size_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_difference_type = root::__gnu_cxx::__alloc_traits__Base_type;
        pub type __alloc_traits_reference = *mut root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits_const_reference = *const root::__gnu_cxx::__alloc_traits_value_type;
        pub type __alloc_traits___is_custom_pointer = root::std::__and_;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __alloc_traits_rebind {
            pub _address: u8,
        }
        pub type __alloc_traits_rebind_other = root::__gnu_cxx::__alloc_traits__Base_type;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __aligned_membuf {
            pub _M_storage: *mut ::std::os::raw::c_uchar,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct __aligned_membuf__Tp2<_Tp> {
            pub _M_t: _Tp,
            pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Tp>>,
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct _Char_types {
            pub _address: u8,
        }
        pub type _Char_types_int_type = ::std::os::raw::c_ulong;
        pub type _Char_types_pos_type = root::std::streampos;
        pub type _Char_types_off_type = root::std::streamoff;
        pub type _Char_types_state_type = root::mbstate_t;
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct char_traits {
            pub _address: u8,
        }
        pub type char_traits_char_type<_CharT> = _CharT;
        pub type char_traits_int_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_pos_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_off_type = root::__gnu_cxx::_Char_types;
        pub type char_traits_state_type = root::__gnu_cxx::_Char_types;
    }
    pub type size_t = ::std::os::raw::c_ulong;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub struct __mbstate_t {
        pub __count: ::std::os::raw::c_int,
        pub __value: root::__mbstate_t__bindgen_ty_1,
    }
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union __mbstate_t__bindgen_ty_1 {
        pub __wch: ::std::os::raw::c_uint,
        pub __wchb: [::std::os::raw::c_char; 4usize],
        _bindgen_union_align: u32,
    }
    #[test]
    fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wch)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t__bindgen_ty_1),
                "::",
                stringify!(__wchb)
            )
        );
    }
    #[test]
    fn bindgen_test_layout___mbstate_t() {
        assert_eq!(
            ::std::mem::size_of::<__mbstate_t>(),
            8usize,
            concat!("Size of: ", stringify!(__mbstate_t))
        );
        assert_eq!(
            ::std::mem::align_of::<__mbstate_t>(),
            4usize,
            concat!("Alignment of ", stringify!(__mbstate_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(__mbstate_t),
                "::",
                stringify!(__value)
            )
        );
    }
    pub type mbstate_t = root::__mbstate_t;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __locale_struct {
        pub __locales: [*mut root::__locale_data; 13usize],
        pub __ctype_b: *const ::std::os::raw::c_ushort,
        pub __ctype_tolower: *const ::std::os::raw::c_int,
        pub __ctype_toupper: *const ::std::os::raw::c_int,
        pub __names: [*const ::std::os::raw::c_char; 13usize],
    }
    #[test]
    fn bindgen_test_layout___locale_struct() {
        assert_eq!(
            ::std::mem::size_of::<__locale_struct>(),
            232usize,
            concat!("Size of: ", stringify!(__locale_struct))
        );
        assert_eq!(
            ::std::mem::align_of::<__locale_struct>(),
            8usize,
            concat!("Alignment of ", stringify!(__locale_struct))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__locales)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_b)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_tolower)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__ctype_toupper)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(__locale_struct),
                "::",
                stringify!(__names)
            )
        );
    }
    pub type __locale_t = *mut root::__locale_struct;
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __pthread_internal_list {
        pub __prev: *mut root::__pthread_internal_list,
        pub __next: *mut root::__pthread_internal_list,
    }
    #[test]
    fn bindgen_test_layout___pthread_internal_list() {
        assert_eq!(
            ::std::mem::size_of::<__pthread_internal_list>(),
            16usize,
            concat!("Size of: ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            ::std::mem::align_of::<__pthread_internal_list>(),
            8usize,
            concat!("Alignment of ", stringify!(__pthread_internal_list))
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__prev)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(__pthread_internal_list),
                "::",
                stringify!(__next)
            )
        );
    }
    pub type __pthread_list_t = root::__pthread_internal_list;
    #[repr(C)]
    #[derive(Copy, Clone)]
    pub union pthread_mutex_t {
        pub __data: root::pthread_mutex_t___pthread_mutex_s,
        pub __size: [::std::os::raw::c_char; 40usize],
        pub __align: ::std::os::raw::c_long,
        _bindgen_union_align: [u64; 5usize],
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct pthread_mutex_t___pthread_mutex_s {
        pub __lock: ::std::os::raw::c_int,
        pub __count: ::std::os::raw::c_uint,
        pub __owner: ::std::os::raw::c_int,
        pub __nusers: ::std::os::raw::c_uint,
        pub __kind: ::std::os::raw::c_int,
        pub __spins: ::std::os::raw::c_short,
        pub __elision: ::std::os::raw::c_short,
        pub __list: root::__pthread_list_t,
    }
    #[test]
    fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
        assert_eq!(
            ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
            40usize,
            concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
        );
        assert_eq!(
            ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
            8usize,
            concat!(
                "Alignment of ",
                stringify!(pthread_mutex_t___pthread_mutex_s)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _
                    as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__lock)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _
                    as usize
            },
            4usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__count)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _
                    as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__owner)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _
                    as usize
            },
            12usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__nusers)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _
                    as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__kind)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__spins as *const _
                    as usize
            },
            20usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__spins)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__elision as *const _
                    as usize
            },
            22usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__elision)
            )
        );
        assert_eq!(
            unsafe {
                &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__list as *const _
                    as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t___pthread_mutex_s),
                "::",
                stringify!(__list)
            )
        );
    }
    #[test]
    fn bindgen_test_layout_pthread_mutex_t() {
        assert_eq!(
            ::std::mem::size_of::<pthread_mutex_t>(),
            40usize,
            concat!("Size of: ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            ::std::mem::align_of::<pthread_mutex_t>(),
            8usize,
            concat!("Alignment of ", stringify!(pthread_mutex_t))
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__data)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__size)
            )
        );
        assert_eq!(
            unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(pthread_mutex_t),
                "::",
                stringify!(__align)
            )
        );
    }
    pub type pthread_once_t = ::std::os::raw::c_int;
    pub type __gthread_once_t = root::pthread_once_t;
    pub type __gthread_mutex_t = root::pthread_mutex_t;
    pub type _Atomic_word = ::std::os::raw::c_int;
    pub mod taso {
        #[allow(unused_imports)]
        use self::super::super::root;
        pub type DATATYPE = f32;
        pub const OpType_OP_INPUT: root::taso::OpType = 0;
        pub const OpType_OP_WEIGHT: root::taso::OpType = 1;
        pub const OpType_OP_ANY: root::taso::OpType = 2;
        pub const OpType_OP_CONV2D: root::taso::OpType = 3;
        pub const OpType_OP_DROPOUT: root::taso::OpType = 4;
        pub const OpType_OP_LINEAR: root::taso::OpType = 5;
        pub const OpType_OP_POOL2D_MAX: root::taso::OpType = 6;
        pub const OpType_OP_POOL2D_AVG: root::taso::OpType = 7;
        pub const OpType_OP_RELU: root::taso::OpType = 8;
        pub const OpType_OP_SIGMOID: root::taso::OpType = 9;
        pub const OpType_OP_TANH: root::taso::OpType = 10;
        pub const OpType_OP_BATCHNORM: root::taso::OpType = 11;
        pub const OpType_OP_CONCAT: root::taso::OpType = 12;
        pub const OpType_OP_SPLIT: root::taso::OpType = 13;
        pub const OpType_OP_RESHAPE: root::taso::OpType = 14;
        pub const OpType_OP_TRANSPOSE: root::taso::OpType = 15;
        pub const OpType_OP_EW_ADD: root::taso::OpType = 16;
        pub const OpType_OP_EW_MUL: root::taso::OpType = 17;
        pub const OpType_OP_MATMUL: root::taso::OpType = 18;
        pub const OpType_OP_MUL: root::taso::OpType = 19;
        pub const OpType_OP_ENLARGE: root::taso::OpType = 20;
        pub const OpType_OP_MERGE_GCONV: root::taso::OpType = 21;
        pub const OpType_OP_CONSTANT_IMM: root::taso::OpType = 22;
        pub const OpType_OP_CONSTANT_ICONV: root::taso::OpType = 23;
        pub const OpType_OP_CONSTANT_ONE: root::taso::OpType = 24;
        pub const OpType_OP_CONSTANT_POOL: root::taso::OpType = 25;
        pub const OpType_OP_SQUEEZE: root::taso::OpType = 26;
        pub const OpType_OP_UNSQUEEZE: root::taso::OpType = 27;
        pub const OpType_OP_EW_SUB: root::taso::OpType = 28;
        pub const OpType_OP_EW_DIV: root::taso::OpType = 29;
        pub const OpType_OP_EW_EQUAL: root::taso::OpType = 30;
        pub const OpType_OP_EW_GREATER: root::taso::OpType = 31;
        pub const OpType_OP_EW_LESS: root::taso::OpType = 32;
        pub const OpType_OP_EW_MAX: root::taso::OpType = 33;
        pub const OpType_OP_EW_MIN: root::taso::OpType = 34;
        pub const OpType_OP_REDUCE_ARGMAX: root::taso::OpType = 35;
        pub const OpType_OP_REDUCE_ARGMIN: root::taso::OpType = 36;
        pub const OpType_OP_REDUCE_MAX: root::taso::OpType = 37;
        pub const OpType_OP_REDUCE_MEAN: root::taso::OpType = 38;
        pub const OpType_OP_REDUCE_MIN: root::taso::OpType = 39;
        pub const OpType_OP_REDUCE_PROD: root::taso::OpType = 40;
        pub const OpType_OP_REDUCE_SUM: root::taso::OpType = 41;
        pub const OpType_OP_PAD: root::taso::OpType = 42;
        pub const OpType_OP_SHAPE: root::taso::OpType = 43;
        pub const OpType_OP_SIZE: root::taso::OpType = 44;
        pub const OpType_OP_TOPK: root::taso::OpType = 45;
        pub const OpType_OP_WHERE: root::taso::OpType = 46;
        pub const OpType_OP_CEIL: root::taso::OpType = 47;
        pub const OpType_OP_CAST: root::taso::OpType = 48;
        pub const OpType_OP_EXP: root::taso::OpType = 49;
        pub const OpType_OP_ROUND: root::taso::OpType = 50;
        pub const OpType_OP_LOG: root::taso::OpType = 51;
        pub const OpType_OP_LOGICAL_NOT: root::taso::OpType = 52;
        pub const OpType_OP_SQRT: root::taso::OpType = 53;
        pub const OpType_OP_LEAKYRELU: root::taso::OpType = 54;
        pub const OpType_OP_SLICE: root::taso::OpType = 55;
        pub const OpType_OP_RESIZE: root::taso::OpType = 56;
        pub type OpType = u32;
        #[repr(C)]
        #[repr(align(8))]
        #[derive(Debug, Copy, Clone)]
        pub struct Op {
            pub _bindgen_opaque_blob: [u64; 2usize],
        }
        #[test]
        fn bindgen_test_layout_Op() {
            assert_eq!(
                ::std::mem::size_of::<Op>(),
                16usize,
                concat!("Size of: ", stringify!(Op))
            );
            assert_eq!(
                ::std::mem::align_of::<Op>(),
                8usize,
                concat!("Alignment of ", stringify!(Op))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2Op12op_to_stringB5cxx11EPKNS_6OpBaseE"]
            pub fn Op_op_to_string(
                this: *mut root::taso::Op,
                ptr: *const root::taso::OpBase,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2Op9to_stringB5cxx11Ev"]
            pub fn Op_to_string(this: *mut root::taso::Op) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2OpC1Ev"]
            pub fn Op_Op(this: *mut root::taso::Op);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2OpC1EmPNS_6OpBaseE"]
            pub fn Op_Op1(
                this: *mut root::taso::Op,
                _guid: root::size_t,
                _ptr: *mut root::taso::OpBase,
            );
        }
        impl Op {
            #[inline]
            pub unsafe fn op_to_string(
                &mut self,
                ptr: *const root::taso::OpBase,
            ) -> root::std::string {
                Op_op_to_string(self, ptr)
            }
            #[inline]
            pub unsafe fn to_string(&mut self) -> root::std::string {
                Op_to_string(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Op_Op(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(_guid: root::size_t, _ptr: *mut root::taso::OpBase) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Op_Op1(__bindgen_tmp.as_mut_ptr(), _guid, _ptr);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso2Op10INVALID_OPE"]
            pub static Op_INVALID_OP: root::taso::Op;
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct Edge {
            pub srcOp: root::taso::Op,
            pub dstOp: root::taso::Op,
            pub srcIdx: ::std::os::raw::c_int,
            pub dstIdx: ::std::os::raw::c_int,
        }
        #[test]
        fn bindgen_test_layout_Edge() {
            assert_eq!(
                ::std::mem::size_of::<Edge>(),
                40usize,
                concat!("Size of: ", stringify!(Edge))
            );
            assert_eq!(
                ::std::mem::align_of::<Edge>(),
                8usize,
                concat!("Alignment of ", stringify!(Edge))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).srcOp as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(srcOp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).dstOp as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(dstOp)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).srcIdx as *const _ as usize },
                32usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(srcIdx)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Edge>())).dstIdx as *const _ as usize },
                36usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Edge),
                    "::",
                    stringify!(dstIdx)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4EdgeC1Ev"]
            pub fn Edge_Edge(this: *mut root::taso::Edge);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4EdgeC1ENS_2OpES1_ii"]
            pub fn Edge_Edge1(
                this: *mut root::taso::Edge,
                _srcOp: root::taso::Op,
                _dstOp: root::taso::Op,
                _srcIdx: ::std::os::raw::c_int,
                _dstIdx: ::std::os::raw::c_int,
            );
        }
        impl Edge {
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Edge_Edge(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                _srcOp: root::taso::Op,
                _dstOp: root::taso::Op,
                _srcIdx: ::std::os::raw::c_int,
                _dstIdx: ::std::os::raw::c_int,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Edge_Edge1(__bindgen_tmp.as_mut_ptr(), _srcOp, _dstOp, _srcIdx, _dstIdx);
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct EdgeCompare {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_EdgeCompare() {
            assert_eq!(
                ::std::mem::size_of::<EdgeCompare>(),
                1usize,
                concat!("Size of: ", stringify!(EdgeCompare))
            );
            assert_eq!(
                ::std::mem::align_of::<EdgeCompare>(),
                1usize,
                concat!("Alignment of ", stringify!(EdgeCompare))
            );
        }
        #[repr(C)]
        #[derive(Debug, Copy, Clone)]
        pub struct OpCompare {
            pub _address: u8,
        }
        #[test]
        fn bindgen_test_layout_OpCompare() {
            assert_eq!(
                ::std::mem::size_of::<OpCompare>(),
                1usize,
                concat!("Size of: ", stringify!(OpCompare))
            );
            assert_eq!(
                ::std::mem::align_of::<OpCompare>(),
                1usize,
                concat!("Alignment of ", stringify!(OpCompare))
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        pub struct Tensor {
            pub _bindgen_opaque_blob: [u64; 144usize],
        }
        #[test]
        fn bindgen_test_layout_Tensor() {
            assert_eq!(
                ::std::mem::size_of::<Tensor>(),
                1152usize,
                concat!("Size of: ", stringify!(Tensor))
            );
            assert_eq!(
                ::std::mem::align_of::<Tensor>(),
                8usize,
                concat!("Alignment of ", stringify!(Tensor))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor6volumeEv"]
            pub fn Tensor_volume(this: *const root::taso::Tensor) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Tensor9to_stringENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Tensor_to_string(
                this: *mut root::taso::Tensor,
                name: root::std::string,
            ) -> root::std::string;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor9serializeEPiRi"]
            pub fn Tensor_serialize(
                this: *const root::taso::Tensor,
                keys: *mut ::std::os::raw::c_int,
                idx: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor27has_same_shape_stride_splitERKS0_"]
            pub fn Tensor_has_same_shape_stride_split(
                this: *const root::taso::Tensor,
                tensor: *const root::taso::Tensor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso6Tensor14default_layoutEv"]
            pub fn Tensor_default_layout(this: *const root::taso::Tensor) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6TensorC1Ev"]
            pub fn Tensor_Tensor(this: *mut root::taso::Tensor);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6TensorC1EiPKimPf"]
            pub fn Tensor_Tensor1(
                this: *mut root::taso::Tensor,
                ndim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                guid: root::size_t,
                data: *mut root::taso::DATATYPE,
            );
        }
        impl Tensor {
            #[inline]
            pub unsafe fn volume(&self) -> ::std::os::raw::c_int {
                Tensor_volume(self)
            }
            #[inline]
            pub unsafe fn to_string(&mut self, name: root::std::string) -> root::std::string {
                Tensor_to_string(self, name)
            }
            #[inline]
            pub unsafe fn serialize(
                &self,
                keys: *mut ::std::os::raw::c_int,
                idx: *mut ::std::os::raw::c_int,
            ) {
                Tensor_serialize(self, keys, idx)
            }
            #[inline]
            pub unsafe fn has_same_shape_stride_split(
                &self,
                tensor: *const root::taso::Tensor,
            ) -> bool {
                Tensor_has_same_shape_stride_split(self, tensor)
            }
            #[inline]
            pub unsafe fn default_layout(&self) -> bool {
                Tensor_default_layout(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Tensor_Tensor(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                ndim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                guid: root::size_t,
                data: *mut root::taso::DATATYPE,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Tensor_Tensor1(__bindgen_tmp.as_mut_ptr(), ndim, dims, guid, data);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Tensor14MAX_KEY_LENGTHE"]
            pub static Tensor_MAX_KEY_LENGTH: ::std::os::raw::c_int;
        }
        pub const Tensor_MAGIC_NUMBER: ::std::os::raw::c_int = 23333;
        pub type TensorHandle = *mut root::taso::Tensor;
        pub const DataType_DT_FLOAT: root::taso::DataType = 111;
        pub const DataType_DT_DOUBLE: root::taso::DataType = 222;
        pub const DataType_DT_HALF: root::taso::DataType = 333;
        pub const DataType_DT_INT8: root::taso::DataType = 444;
        pub const DataType_DT_UINT8: root::taso::DataType = 555;
        pub const DataType_DT_INT32: root::taso::DataType = 666;
        pub const DataType_DT_INT64: root::taso::DataType = 777;
        pub const DataType_DT_BOOL: root::taso::DataType = 888;
        pub type DataType = u32;
        pub const PMParameter_PM_OP_TYPE: root::taso::PMParameter = 0;
        pub const PMParameter_PM_NUM_INPUTS: root::taso::PMParameter = 1;
        pub const PMParameter_PM_NUM_OUTPUTS: root::taso::PMParameter = 2;
        pub const PMParameter_PM_GROUP: root::taso::PMParameter = 3;
        pub const PMParameter_PM_KERNEL_H: root::taso::PMParameter = 4;
        pub const PMParameter_PM_KERNEL_W: root::taso::PMParameter = 5;
        pub const PMParameter_PM_STRIDE_H: root::taso::PMParameter = 6;
        pub const PMParameter_PM_STRIDE_W: root::taso::PMParameter = 7;
        pub const PMParameter_PM_PAD: root::taso::PMParameter = 8;
        pub const PMParameter_PM_ACTI: root::taso::PMParameter = 9;
        pub const PMParameter_PM_NUMDIM: root::taso::PMParameter = 10;
        pub const PMParameter_PM_AXIS: root::taso::PMParameter = 11;
        pub const PMParameter_PM_PERM: root::taso::PMParameter = 12;
        pub const PMParameter_PM_OUTSHUFFLE: root::taso::PMParameter = 13;
        pub const PMParameter_PM_MERGE_GCONV_COUNT: root::taso::PMParameter = 14;
        pub const PMParameter_PM_AXES: root::taso::PMParameter = 15;
        pub const PMParameter_PM_KEEP_DIMS: root::taso::PMParameter = 16;
        pub type PMParameter = u32;
        pub const TNParameter_IN_0: root::taso::TNParameter = 100;
        pub const TNParameter_IN_1: root::taso::TNParameter = 101;
        pub const TNParameter_IN_2: root::taso::TNParameter = 102;
        pub const TNParameter_IN_3: root::taso::TNParameter = 103;
        pub const TNParameter_IN_4: root::taso::TNParameter = 104;
        pub const TNParameter_IN_5: root::taso::TNParameter = 105;
        pub const TNParameter_OU_0: root::taso::TNParameter = 200;
        pub const TNParameter_OU_1: root::taso::TNParameter = 201;
        pub const TNParameter_OU_2: root::taso::TNParameter = 202;
        pub const TNParameter_OU_3: root::taso::TNParameter = 203;
        pub const TNParameter_OU_4: root::taso::TNParameter = 204;
        pub const TNParameter_OU_5: root::taso::TNParameter = 205;
        pub type TNParameter = u32;
        pub const DIMParameter_DIM_0: root::taso::DIMParameter = 300;
        pub const DIMParameter_DIM_1: root::taso::DIMParameter = 301;
        pub const DIMParameter_DIM_2: root::taso::DIMParameter = 302;
        pub const DIMParameter_DIM_3: root::taso::DIMParameter = 303;
        pub const DIMParameter_DIM_ND: root::taso::DIMParameter = 310;
        pub type DIMParameter = u32;
        pub const ActiMode_AC_MODE_NONE: root::taso::ActiMode = 0;
        pub const ActiMode_AC_MODE_SIGMOID: root::taso::ActiMode = 1;
        pub const ActiMode_AC_MODE_RELU: root::taso::ActiMode = 2;
        pub const ActiMode_AC_MODE_TANH: root::taso::ActiMode = 3;
        pub type ActiMode = u32;
        pub const PaddingMode_PD_MODE_SAME: root::taso::PaddingMode = 0;
        pub const PaddingMode_PD_MODE_VALID: root::taso::PaddingMode = 1;
        pub type PaddingMode = u32;
        #[repr(C)]
        pub struct OpBase__bindgen_vtable(::std::os::raw::c_void);
        #[repr(C)]
        pub struct OpBase {
            pub vtable_: *const OpBase__bindgen_vtable,
            pub inputs: [root::taso::Tensor; 6usize],
            pub outputs: [root::taso::Tensor; 6usize],
            pub numInputs: ::std::os::raw::c_int,
            pub numOutputs: ::std::os::raw::c_int,
            pub model: *mut root::taso::Model,
            pub type_: root::taso::OpType,
            pub runtime: f32,
        }
        #[test]
        fn bindgen_test_layout_OpBase() {
            assert_eq!(
                ::std::mem::size_of::<OpBase>(),
                13856usize,
                concat!("Size of: ", stringify!(OpBase))
            );
            assert_eq!(
                ::std::mem::align_of::<OpBase>(),
                8usize,
                concat!("Alignment of ", stringify!(OpBase))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).inputs as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(inputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).outputs as *const _ as usize },
                6920usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(outputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).numInputs as *const _ as usize },
                13832usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(numInputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).numOutputs as *const _ as usize },
                13836usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(numOutputs)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).model as *const _ as usize },
                13840usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(model)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).type_ as *const _ as usize },
                13848usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(type_)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<OpBase>())).runtime as *const _ as usize },
                13852usize,
                concat!(
                    "Offset of field: ",
                    stringify!(OpBase),
                    "::",
                    stringify!(runtime)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2EPNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase(
                this: *mut root::taso::OpBase,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorEPNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase1(
                this: *mut root::taso::OpBase,
                input: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorES3_PNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase2(
                this: *mut root::taso::OpBase,
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorES3_S3_PNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase3(
                this: *mut root::taso::OpBase,
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2ERKNS_6TensorES3_S3_S3_S3_PNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase4(
                this: *mut root::taso::OpBase,
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                input3: *const root::taso::Tensor,
                input4: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBaseC2EiPNS_6TensorEPNS_5ModelENS_6OpTypeE"]
            pub fn OpBase_OpBase5(
                this: *mut root::taso::OpBase,
                n: ::std::os::raw::c_int,
                inputs: *mut root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            );
        }
        impl OpBase {
            #[inline]
            pub unsafe fn new(_model: *mut root::taso::Model, _type: root::taso::OpType) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase(__bindgen_tmp.as_mut_ptr(), _model, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new1(
                input: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase1(__bindgen_tmp.as_mut_ptr(), input, _model, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new2(
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase2(__bindgen_tmp.as_mut_ptr(), input0, input1, _model, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new3(
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase3(
                    __bindgen_tmp.as_mut_ptr(),
                    input0,
                    input1,
                    input2,
                    _model,
                    _type,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new4(
                input0: *const root::taso::Tensor,
                input1: *const root::taso::Tensor,
                input2: *const root::taso::Tensor,
                input3: *const root::taso::Tensor,
                input4: *const root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase4(
                    __bindgen_tmp.as_mut_ptr(),
                    input0,
                    input1,
                    input2,
                    input3,
                    input4,
                    _model,
                    _type,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn new5(
                n: ::std::os::raw::c_int,
                inputs: *mut root::taso::Tensor,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                OpBase_OpBase5(__bindgen_tmp.as_mut_ptr(), n, inputs, _model, _type);
                __bindgen_tmp.assume_init()
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBase19get_input_parameterENS_11TNParameterENS_12DIMParameterEPi"]
            pub fn OpBase_get_input_parameter(
                this: *mut ::std::os::raw::c_void,
                arg1: root::taso::TNParameter,
                arg2: root::taso::DIMParameter,
                arg3: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6OpBase17get_int_parameterENS_11PMParameterEPi"]
            pub fn OpBase_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                arg1: root::taso::PMParameter,
                arg2: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Graph {
            pub model: *mut root::taso::Model,
            pub totalCost: f32,
            pub inEdges: [u64; 6usize],
            pub outEdges: [u64; 6usize],
            pub subst_history: [u64; 3usize],
        }
        #[repr(C)]
        #[derive(Debug)]
        pub struct Graph_GraphSubst {
            pub srcOps: [u64; 3usize],
            pub dstOps: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Graph_GraphSubst() {
            assert_eq!(
                ::std::mem::size_of::<Graph_GraphSubst>(),
                48usize,
                concat!("Size of: ", stringify!(Graph_GraphSubst))
            );
            assert_eq!(
                ::std::mem::align_of::<Graph_GraphSubst>(),
                8usize,
                concat!("Alignment of ", stringify!(Graph_GraphSubst))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph_GraphSubst>())).srcOps as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph_GraphSubst),
                    "::",
                    stringify!(srcOps)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph_GraphSubst>())).dstOps as *const _ as usize },
                24usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph_GraphSubst),
                    "::",
                    stringify!(dstOps)
                )
            );
        }
        #[test]
        fn bindgen_test_layout_Graph() {
            assert_eq!(
                ::std::mem::size_of::<Graph>(),
                136usize,
                concat!("Size of: ", stringify!(Graph))
            );
            assert_eq!(
                ::std::mem::align_of::<Graph>(),
                8usize,
                concat!("Alignment of ", stringify!(Graph))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).model as *const _ as usize },
                0usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(model)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).totalCost as *const _ as usize },
                8usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(totalCost)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).inEdges as *const _ as usize },
                16usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(inEdges)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).outEdges as *const _ as usize },
                64usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(outEdges)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Graph>())).subst_history as *const _ as usize },
                112usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Graph),
                    "::",
                    stringify!(subst_history)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9new_inputEiPKi"]
            pub fn Graph_new_input(
                this: *mut root::taso::Graph,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10new_weightEiPKiPKf"]
            pub fn Graph_new_weight(
                this: *mut root::taso::Graph,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                data: *const root::taso::DATATYPE,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10new_weightERKNS_6TensorE"]
            pub fn Graph_new_weight1(
                this: *mut root::taso::Graph,
                input: *const root::taso::Tensor,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8add_edgeENS_2OpES1_ii"]
            pub fn Graph_add_edge(
                this: *mut root::taso::Graph,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11remove_edgeENS_4EdgeE"]
            pub fn Graph_remove_edge(this: *mut root::taso::Graph, e: root::taso::Edge);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8has_edgeENS_2OpES1_ii"]
            pub fn Graph_has_edge(
                this: *mut root::taso::Graph,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph12replace_nodeENS_2OpES1_"]
            pub fn Graph_replace_node(
                this: *mut root::taso::Graph,
                oldOp: root::taso::Op,
                newOp: root::taso::Op,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11remove_nodeENS_2OpE"]
            pub fn Graph_remove_node(this: *mut root::taso::Graph, oldOp: root::taso::Op);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph14export_to_fileENSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"]
            pub fn Graph_export_to_file(this: *mut root::taso::Graph, file_name: root::std::string);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph12group_conv2dEiPNS_6TensorEiiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_group_conv2d(
                this: *mut root::taso::Graph,
                groups: ::std::os::raw::c_int,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9batchnormEPNS_6TensorES2_S2_S2_S2_"]
            pub fn Graph_batchnorm(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _scale: root::taso::TensorHandle,
                _bias: root::taso::TensorHandle,
                _mean: root::taso::TensorHandle,
                _var: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4castEPNS_6TensorENS_8DataTypeE"]
            pub fn Graph_cast(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _datatype: root::taso::DataType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4ceilEPNS_6TensorE"]
            pub fn Graph_ceil(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6concatEiiPKPNS_6TensorE"]
            pub fn Graph_concat(
                this: *mut root::taso::Graph,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *const root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8constantEiPiNS_6OpTypeE"]
            pub fn Graph_constant(
                this: *mut root::taso::Graph,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6conv2dEPNS_6TensorEiiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_conv2d(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6conv2dEPNS_6TensorES2_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_conv2d1(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7dropoutEPNS_6TensorE"]
            pub fn Graph_dropout(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7elementENS_6OpTypeEPNS_6TensorES3_"]
            pub fn Graph_element(
                this: *mut root::taso::Graph,
                type_: root::taso::OpType,
                _t1: root::taso::TensorHandle,
                _t2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17elementwise_unaryEPNS_6TensorENS_6OpTypeE"]
            pub fn Graph_elementwise_unary(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7enlargeEPNS_6TensorES2_"]
            pub fn Graph_enlarge(
                this: *mut root::taso::Graph,
                _w1: root::taso::TensorHandle,
                _w2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3expEPNS_6TensorE"]
            pub fn Graph_exp(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph2fcEPNS_6TensorEiNS_8ActiModeE"]
            pub fn Graph_fc(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9leakyreluEPNS_6TensorEfb"]
            pub fn Graph_leakyrelu(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _alpha: f32,
                _inplace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3logEPNS_6TensorE"]
            pub fn Graph_log(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11logical_notEPNS_6TensorE"]
            pub fn Graph_logical_not(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6matmulEPNS_6TensorES2_NS_8ActiModeE"]
            pub fn Graph_matmul(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11merge_gconvEPNS_6TensorEi"]
            pub fn Graph_merge_gconv(
                this: *mut root::taso::Graph,
                _weight: root::taso::TensorHandle,
                count: ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3mulEPNS_6TensorES2_"]
            pub fn Graph_mul(
                this: *mut root::taso::Graph,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3padEPNS_6TensorERKSt6vectorIiSaIiEES7_f"]
            pub fn Graph_pad(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10pool2d_maxEPNS_6TensorEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_pool2d_max(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10pool2d_avgEPNS_6TensorEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Graph_pool2d_avg(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6reduceEPNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph13reduce_argmaxEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_argmax(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph13reduce_argminEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_argmin(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10reduce_maxEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_max(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11reduce_meanEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_mean(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10reduce_minEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_min(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11reduce_prodEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_prod(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10reduce_sumEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_reduce_sum(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4reluEPNS_6TensorEb"]
            pub fn Graph_relu(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7reshapeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_reshape(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph6resizeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_resize(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5roundEPNS_6TensorE"]
            pub fn Graph_round(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5shapeEPNS_6TensorENS_6OpTypeE"]
            pub fn Graph_shape(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5sliceEPNS_6TensorERKSt6vectorIiSaIiEES7_S7_S7_"]
            pub fn Graph_slice(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7sigmoidEPNS_6TensorEb"]
            pub fn Graph_sigmoid(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5splitEPNS_6TensorEiRKSt6vectorIiSaIiEEPS2_"]
            pub fn Graph_split(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
                _outputs: *mut root::taso::TensorHandle,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11split_equalEPNS_6TensorEiiPS2_"]
            pub fn Graph_split_equal(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _num: ::std::os::raw::c_int,
                _outputs: *mut root::taso::TensorHandle,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4sqrtEPNS_6TensorE"]
            pub fn Graph_sqrt(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph7squeezeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_squeeze(
                this: *mut root::taso::Graph,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9transposeEPNS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Graph_transpose(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4tanhEPNS_6TensorEb"]
            pub fn Graph_tanh(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4topkEPNS_6TensorEiibbS2_"]
            pub fn Graph_topk(
                this: *mut root::taso::Graph,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
                outputs: *mut root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph9unsqueezeEPNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Graph_unsqueeze(
                this: *mut root::taso::Graph,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5whereEPNS_6TensorES2_S2_"]
            pub fn Graph_where(
                this: *mut root::taso::Graph,
                _cond: root::taso::TensorHandle,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15find_op_or_failEm"]
            pub fn Graph_find_op_or_fail(
                this: *mut root::taso::Graph,
                guid: root::size_t,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8optimizeEfib"]
            pub fn Graph_optimize(
                this: *mut root::taso::Graph,
                alpha: f32,
                budget: ::std::os::raw::c_int,
                print_subst: bool,
            ) -> *mut root::taso::Graph;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph18preprocess_weightsEv"]
            pub fn Graph_preprocess_weights(this: *mut root::taso::Graph)
                -> *mut root::taso::Graph;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17get_operator_listEPNS_2OpEm"]
            pub fn Graph_get_operator_list(
                this: *mut root::taso::Graph,
                opList: *mut root::taso::Op,
                maxNumOps: root::size_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15get_input_edgesEPNS_4EdgeEm"]
            pub fn Graph_get_input_edges(
                this: *mut root::taso::Graph,
                opList: *mut root::taso::Edge,
                guid: root::size_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17get_operator_typeEm"]
            pub fn Graph_get_operator_type(
                this: *mut root::taso::Graph,
                guid: root::size_t,
            ) -> root::taso::OpType;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph21get_operator_int_attrEmNS_11PMParameterE"]
            pub fn Graph_get_operator_int_attr(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                attr: root::taso::PMParameter,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15get_num_outputsEm"]
            pub fn Graph_get_num_outputs(
                this: *mut root::taso::Graph,
                guid: root::size_t,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph14get_input_dimsEmPii"]
            pub fn Graph_get_input_dims(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph16get_weight_valueEmPf"]
            pub fn Graph_get_weight_value(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                value: *mut root::taso::DATATYPE,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph15get_output_dimsEmPii"]
            pub fn Graph_get_output_dims(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph14get_split_lensEmPi"]
            pub fn Graph_get_split_lens(
                this: *mut root::taso::Graph,
                guid: root::size_t,
                lens: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph12num_in_edgesENS_2OpE"]
            pub fn Graph_num_in_edges(
                this: *mut root::taso::Graph,
                op: root::taso::Op,
            ) -> root::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph13num_out_edgesENS_2OpE"]
            pub fn Graph_num_out_edges(
                this: *mut root::taso::Graph,
                op: root::taso::Op,
            ) -> root::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph4hashEv"]
            pub fn Graph_hash(this: *mut root::taso::Graph) -> root::size_t;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph5printEv"]
            pub fn Graph_print(this: *mut root::taso::Graph);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph17check_correctnessEv"]
            pub fn Graph_check_correctness(this: *mut root::taso::Graph) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph8has_loopEv"]
            pub fn Graph_has_loop(this: *mut root::taso::Graph) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph10total_costEv"]
            pub fn Graph_total_cost(this: *mut root::taso::Graph) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph3runEv"]
            pub fn Graph_run(this: *mut root::taso::Graph) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph11print_costsEv"]
            pub fn Graph_print_costs(this: *mut root::taso::Graph);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Graph18print_measurementsEv"]
            pub fn Graph_print_measurements(this: *mut root::taso::Graph);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5GraphC1Ev"]
            pub fn Graph_Graph(this: *mut root::taso::Graph);
        }
        impl Graph {
            #[inline]
            pub unsafe fn new_input(
                &mut self,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle {
                Graph_new_input(self, dim, dims)
            }
            #[inline]
            pub unsafe fn new_weight(
                &mut self,
                dim: ::std::os::raw::c_int,
                dims: *const ::std::os::raw::c_int,
                data: *const root::taso::DATATYPE,
            ) -> root::taso::TensorHandle {
                Graph_new_weight(self, dim, dims, data)
            }
            #[inline]
            pub unsafe fn new_weight1(
                &mut self,
                input: *const root::taso::Tensor,
            ) -> root::taso::TensorHandle {
                Graph_new_weight1(self, input)
            }
            #[inline]
            pub unsafe fn add_edge(
                &mut self,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            ) {
                Graph_add_edge(self, srcOp, dstOp, srcIdx, dstIdx)
            }
            #[inline]
            pub unsafe fn remove_edge(&mut self, e: root::taso::Edge) {
                Graph_remove_edge(self, e)
            }
            #[inline]
            pub unsafe fn has_edge(
                &mut self,
                srcOp: root::taso::Op,
                dstOp: root::taso::Op,
                srcIdx: ::std::os::raw::c_int,
                dstIdx: ::std::os::raw::c_int,
            ) -> bool {
                Graph_has_edge(self, srcOp, dstOp, srcIdx, dstIdx)
            }
            #[inline]
            pub unsafe fn replace_node(&mut self, oldOp: root::taso::Op, newOp: root::taso::Op) {
                Graph_replace_node(self, oldOp, newOp)
            }
            #[inline]
            pub unsafe fn remove_node(&mut self, oldOp: root::taso::Op) {
                Graph_remove_node(self, oldOp)
            }
            #[inline]
            pub unsafe fn export_to_file(&mut self, file_name: root::std::string) {
                Graph_export_to_file(self, file_name)
            }
            #[inline]
            pub unsafe fn group_conv2d(
                &mut self,
                groups: ::std::os::raw::c_int,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_group_conv2d(
                    self,
                    groups,
                    _input,
                    _outputC,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn batchnorm(
                &mut self,
                _input: root::taso::TensorHandle,
                _scale: root::taso::TensorHandle,
                _bias: root::taso::TensorHandle,
                _mean: root::taso::TensorHandle,
                _var: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_batchnorm(self, _input, _scale, _bias, _mean, _var)
            }
            #[inline]
            pub unsafe fn cast(
                &mut self,
                _input: root::taso::TensorHandle,
                _datatype: root::taso::DataType,
            ) -> root::taso::TensorHandle {
                Graph_cast(self, _input, _datatype)
            }
            #[inline]
            pub unsafe fn ceil(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_ceil(self, _input)
            }
            #[inline]
            pub unsafe fn concat(
                &mut self,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *const root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_concat(self, axis, n, _inputs)
            }
            #[inline]
            pub unsafe fn constant(
                &mut self,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle {
                Graph_constant(self, ndim, dims, _type)
            }
            #[inline]
            pub unsafe fn conv2d(
                &mut self,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_conv2d(
                    self,
                    _input,
                    _outputC,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn conv2d1(
                &mut self,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_conv2d1(
                    self,
                    _input,
                    _weight,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn dropout(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_dropout(self, _input)
            }
            #[inline]
            pub unsafe fn element(
                &mut self,
                type_: root::taso::OpType,
                _t1: root::taso::TensorHandle,
                _t2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_element(self, type_, _t1, _t2)
            }
            #[inline]
            pub unsafe fn elementwise_unary(
                &mut self,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle {
                Graph_elementwise_unary(self, _input, _type)
            }
            #[inline]
            pub unsafe fn enlarge(
                &mut self,
                _w1: root::taso::TensorHandle,
                _w2: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_enlarge(self, _w1, _w2)
            }
            #[inline]
            pub unsafe fn exp(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_exp(self, _input)
            }
            #[inline]
            pub unsafe fn fc(
                &mut self,
                _input: root::taso::TensorHandle,
                _outputC: ::std::os::raw::c_int,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_fc(self, _input, _outputC, _actiMode)
            }
            #[inline]
            pub unsafe fn leakyrelu(
                &mut self,
                _input: root::taso::TensorHandle,
                _alpha: f32,
                _inplace: bool,
            ) -> root::taso::TensorHandle {
                Graph_leakyrelu(self, _input, _alpha, _inplace)
            }
            #[inline]
            pub unsafe fn log(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_log(self, _input)
            }
            #[inline]
            pub unsafe fn logical_not(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_logical_not(self, _input)
            }
            #[inline]
            pub unsafe fn matmul(
                &mut self,
                _input: root::taso::TensorHandle,
                _weight: root::taso::TensorHandle,
                _actiMode: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_matmul(self, _input, _weight, _actiMode)
            }
            #[inline]
            pub unsafe fn merge_gconv(
                &mut self,
                _weight: root::taso::TensorHandle,
                count: ::std::os::raw::c_int,
            ) -> root::taso::TensorHandle {
                Graph_merge_gconv(self, _weight, count)
            }
            #[inline]
            pub unsafe fn mul(
                &mut self,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_mul(self, _x, _y)
            }
            #[inline]
            pub unsafe fn pad(
                &mut self,
                _input: root::taso::TensorHandle,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::TensorHandle {
                Graph_pad(self, _input, _pad_before, _pad_after, _pad_value)
            }
            #[inline]
            pub unsafe fn pool2d_max(
                &mut self,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_pool2d_max(
                    self,
                    _input,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn pool2d_avg(
                &mut self,
                _input: root::taso::TensorHandle,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::TensorHandle {
                Graph_pool2d_avg(
                    self,
                    _input,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn reduce(
                &mut self,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce(self, _input, _type, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_argmax(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_argmax(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_argmin(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_argmin(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_max(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_max(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_mean(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_mean(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_min(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_min(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_prod(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_prod(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn reduce_sum(
                &mut self,
                _input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
                keepdims: bool,
            ) -> root::taso::TensorHandle {
                Graph_reduce_sum(self, _input, axes, keepdims)
            }
            #[inline]
            pub unsafe fn relu(
                &mut self,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle {
                Graph_relu(self, _input, _inPlace)
            }
            #[inline]
            pub unsafe fn reshape(
                &mut self,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_reshape(self, _input, _shape)
            }
            #[inline]
            pub unsafe fn resize(
                &mut self,
                _input: root::taso::TensorHandle,
                _shape: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_resize(self, _input, _shape)
            }
            #[inline]
            pub unsafe fn round(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_round(self, _input)
            }
            #[inline]
            pub unsafe fn shape(
                &mut self,
                _input: root::taso::TensorHandle,
                _type: root::taso::OpType,
            ) -> root::taso::TensorHandle {
                Graph_shape(self, _input, _type)
            }
            #[inline]
            pub unsafe fn slice(
                &mut self,
                _input: root::taso::TensorHandle,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_slice(self, _input, _start, _end, _axes, _steps)
            }
            #[inline]
            pub unsafe fn sigmoid(
                &mut self,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle {
                Graph_sigmoid(self, _input, _inPlace)
            }
            #[inline]
            pub unsafe fn split(
                &mut self,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
                _outputs: *mut root::taso::TensorHandle,
            ) {
                Graph_split(self, _input, _axis, _sizes, _outputs)
            }
            #[inline]
            pub unsafe fn split_equal(
                &mut self,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _num: ::std::os::raw::c_int,
                _outputs: *mut root::taso::TensorHandle,
            ) {
                Graph_split_equal(self, _input, _axis, _num, _outputs)
            }
            #[inline]
            pub unsafe fn sqrt(
                &mut self,
                _input: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_sqrt(self, _input)
            }
            #[inline]
            pub unsafe fn squeeze(
                &mut self,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_squeeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn transpose(
                &mut self,
                _input: root::taso::TensorHandle,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::TensorHandle {
                Graph_transpose(self, _input, _perm, _shuffle)
            }
            #[inline]
            pub unsafe fn tanh(
                &mut self,
                _input: root::taso::TensorHandle,
                _inPlace: bool,
            ) -> root::taso::TensorHandle {
                Graph_tanh(self, _input, _inPlace)
            }
            #[inline]
            pub unsafe fn topk(
                &mut self,
                _input: root::taso::TensorHandle,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
                outputs: *mut root::taso::Tensor,
            ) {
                Graph_topk(self, _input, _axis, _numk, _largest, _sorted, outputs)
            }
            #[inline]
            pub unsafe fn unsqueeze(
                &mut self,
                input: root::taso::TensorHandle,
                axes: *const [u64; 3usize],
            ) -> root::taso::TensorHandle {
                Graph_unsqueeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn where_(
                &mut self,
                _cond: root::taso::TensorHandle,
                _x: root::taso::TensorHandle,
                _y: root::taso::TensorHandle,
            ) -> root::taso::TensorHandle {
                Graph_where(self, _cond, _x, _y)
            }
            #[inline]
            pub unsafe fn find_op_or_fail(&mut self, guid: root::size_t) -> root::taso::Op {
                Graph_find_op_or_fail(self, guid)
            }
            #[inline]
            pub unsafe fn optimize(
                &mut self,
                alpha: f32,
                budget: ::std::os::raw::c_int,
                print_subst: bool,
            ) -> *mut root::taso::Graph {
                Graph_optimize(self, alpha, budget, print_subst)
            }
            #[inline]
            pub unsafe fn preprocess_weights(&mut self) -> *mut root::taso::Graph {
                Graph_preprocess_weights(self)
            }
            #[inline]
            pub unsafe fn get_operator_list(
                &mut self,
                opList: *mut root::taso::Op,
                maxNumOps: root::size_t,
            ) -> ::std::os::raw::c_int {
                Graph_get_operator_list(self, opList, maxNumOps)
            }
            #[inline]
            pub unsafe fn get_input_edges(
                &mut self,
                opList: *mut root::taso::Edge,
                guid: root::size_t,
            ) -> ::std::os::raw::c_int {
                Graph_get_input_edges(self, opList, guid)
            }
            #[inline]
            pub unsafe fn get_operator_type(&mut self, guid: root::size_t) -> root::taso::OpType {
                Graph_get_operator_type(self, guid)
            }
            #[inline]
            pub unsafe fn get_operator_int_attr(
                &mut self,
                guid: root::size_t,
                attr: root::taso::PMParameter,
            ) -> ::std::os::raw::c_int {
                Graph_get_operator_int_attr(self, guid, attr)
            }
            #[inline]
            pub unsafe fn get_num_outputs(&mut self, guid: root::size_t) -> ::std::os::raw::c_int {
                Graph_get_num_outputs(self, guid)
            }
            #[inline]
            pub unsafe fn get_input_dims(
                &mut self,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                Graph_get_input_dims(self, guid, dims, idx)
            }
            #[inline]
            pub unsafe fn get_weight_value(
                &mut self,
                guid: root::size_t,
                value: *mut root::taso::DATATYPE,
            ) {
                Graph_get_weight_value(self, guid, value)
            }
            #[inline]
            pub unsafe fn get_output_dims(
                &mut self,
                guid: root::size_t,
                dims: *mut ::std::os::raw::c_int,
                idx: ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                Graph_get_output_dims(self, guid, dims, idx)
            }
            #[inline]
            pub unsafe fn get_split_lens(
                &mut self,
                guid: root::size_t,
                lens: *mut ::std::os::raw::c_int,
            ) -> ::std::os::raw::c_int {
                Graph_get_split_lens(self, guid, lens)
            }
            #[inline]
            pub unsafe fn num_in_edges(&mut self, op: root::taso::Op) -> root::size_t {
                Graph_num_in_edges(self, op)
            }
            #[inline]
            pub unsafe fn num_out_edges(&mut self, op: root::taso::Op) -> root::size_t {
                Graph_num_out_edges(self, op)
            }
            #[inline]
            pub unsafe fn hash(&mut self) -> root::size_t {
                Graph_hash(self)
            }
            #[inline]
            pub unsafe fn print(&mut self) {
                Graph_print(self)
            }
            #[inline]
            pub unsafe fn check_correctness(&mut self) -> bool {
                Graph_check_correctness(self)
            }
            #[inline]
            pub unsafe fn has_loop(&mut self) -> bool {
                Graph_has_loop(self)
            }
            #[inline]
            pub unsafe fn total_cost(&mut self) -> f32 {
                Graph_total_cost(self)
            }
            #[inline]
            pub unsafe fn run(&mut self) -> f32 {
                Graph_run(self)
            }
            #[inline]
            pub unsafe fn print_costs(&mut self) {
                Graph_print_costs(self)
            }
            #[inline]
            pub unsafe fn print_measurements(&mut self) {
                Graph_print_measurements(self)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Graph_Graph(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
        #[repr(C)]
        pub struct Conv2D {
            pub _base: root::taso::OpBase,
            pub strideH: ::std::os::raw::c_int,
            pub strideW: ::std::os::raw::c_int,
            pub padding: root::taso::PaddingMode,
            pub activation: root::taso::ActiMode,
            pub biasPtr: *mut ::std::os::raw::c_void,
        }
        #[test]
        fn bindgen_test_layout_Conv2D() {
            assert_eq!(
                ::std::mem::size_of::<Conv2D>(),
                13880usize,
                concat!("Size of: ", stringify!(Conv2D))
            );
            assert_eq!(
                ::std::mem::align_of::<Conv2D>(),
                8usize,
                concat!("Alignment of ", stringify!(Conv2D))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).strideH as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(strideH)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).strideW as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(strideW)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).padding as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(padding)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).activation as *const _ as usize },
                13868usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(activation)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Conv2D>())).biasPtr as *const _ as usize },
                13872usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Conv2D),
                    "::",
                    stringify!(biasPtr)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D11get_paddingEPiS1_"]
            pub fn Conv2D_get_padding(
                this: *mut root::taso::Conv2D,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2DC1EPNS_5ModelENS_6TensorES3_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Conv2D_Conv2D(
                this: *mut root::taso::Conv2D,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2DD1Ev"]
            pub fn Conv2D_Conv2D_destructor(this: *mut root::taso::Conv2D);
        }
        impl Conv2D {
            #[inline]
            pub unsafe fn get_padding(
                &mut self,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            ) {
                Conv2D_get_padding(self, padH, padW)
            }
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Conv2D_Conv2D(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _weight,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Conv2D_Conv2D_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D7forwardEb"]
            pub fn Conv2D_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D3mapEv"]
            pub fn Conv2D_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D5unmapEv"]
            pub fn Conv2D_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D17get_int_parameterENS_11PMParameterEPi"]
            pub fn Conv2D_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Conv2D13collect_costsERfS1_S1_Ri"]
            pub fn Conv2D_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Matmul {
            pub _base: root::taso::OpBase,
            pub outputC: ::std::os::raw::c_int,
            pub activation: root::taso::ActiMode,
        }
        #[test]
        fn bindgen_test_layout_Matmul() {
            assert_eq!(
                ::std::mem::size_of::<Matmul>(),
                13864usize,
                concat!("Size of: ", stringify!(Matmul))
            );
            assert_eq!(
                ::std::mem::align_of::<Matmul>(),
                8usize,
                concat!("Alignment of ", stringify!(Matmul))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Matmul>())).outputC as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Matmul),
                    "::",
                    stringify!(outputC)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Matmul>())).activation as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Matmul),
                    "::",
                    stringify!(activation)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6MatmulC1EPNS_5ModelENS_6TensorES3_NS_8ActiModeE"]
            pub fn Matmul_Matmul(
                this: *mut root::taso::Matmul,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actiMode: root::taso::ActiMode,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6MatmulD1Ev"]
            pub fn Matmul_Matmul_destructor(this: *mut root::taso::Matmul);
        }
        impl Matmul {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actiMode: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Matmul_Matmul(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _weight,
                    _actiMode,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Matmul_Matmul_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul7forwardEb"]
            pub fn Matmul_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul3mapEv"]
            pub fn Matmul_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul5unmapEv"]
            pub fn Matmul_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul17get_int_parameterENS_11PMParameterEPi"]
            pub fn Matmul_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Matmul13collect_costsERfS1_S1_Ri"]
            pub fn Matmul_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Mul {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Mul() {
            assert_eq!(
                ::std::mem::size_of::<Mul>(),
                13856usize,
                concat!("Size of: ", stringify!(Mul))
            );
            assert_eq!(
                ::std::mem::align_of::<Mul>(),
                8usize,
                concat!("Alignment of ", stringify!(Mul))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3MulC1EPNS_5ModelERKNS_6TensorES5_"]
            pub fn Mul_Mul(
                this: *mut root::taso::Mul,
                _model: *mut root::taso::Model,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3MulD1Ev"]
            pub fn Mul_Mul_destructor(this: *mut root::taso::Mul);
        }
        impl Mul {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Mul_Mul(__bindgen_tmp.as_mut_ptr(), _model, x, y);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Mul_Mul_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul7forwardEb"]
            pub fn Mul_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul3mapEv"]
            pub fn Mul_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul5unmapEv"]
            pub fn Mul_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul17get_int_parameterENS_11PMParameterEPi"]
            pub fn Mul_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Mul13collect_costsERfS1_S1_Ri"]
            pub fn Mul_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Pool2D {
            pub _base: root::taso::OpBase,
            pub kernelH: ::std::os::raw::c_int,
            pub kernelW: ::std::os::raw::c_int,
            pub strideH: ::std::os::raw::c_int,
            pub strideW: ::std::os::raw::c_int,
            pub padding: root::taso::PaddingMode,
            pub activation: root::taso::ActiMode,
        }
        #[test]
        fn bindgen_test_layout_Pool2D() {
            assert_eq!(
                ::std::mem::size_of::<Pool2D>(),
                13880usize,
                concat!("Size of: ", stringify!(Pool2D))
            );
            assert_eq!(
                ::std::mem::align_of::<Pool2D>(),
                8usize,
                concat!("Alignment of ", stringify!(Pool2D))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).kernelH as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(kernelH)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).kernelW as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(kernelW)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).strideH as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(strideH)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).strideW as *const _ as usize },
                13868usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(strideW)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).padding as *const _ as usize },
                13872usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(padding)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pool2D>())).activation as *const _ as usize },
                13876usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pool2D),
                    "::",
                    stringify!(activation)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D11get_paddingEPiS1_"]
            pub fn Pool2D_get_padding(
                this: *mut root::taso::Pool2D,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2DC1EPNS_5ModelENS_6TensorES3_NS_6OpTypeEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Pool2D_Pool2D(
                this: *mut root::taso::Pool2D,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2DD1Ev"]
            pub fn Pool2D_Pool2D_destructor(this: *mut root::taso::Pool2D);
        }
        impl Pool2D {
            #[inline]
            pub unsafe fn get_padding(
                &mut self,
                padH: *mut ::std::os::raw::c_int,
                padW: *mut ::std::os::raw::c_int,
            ) {
                Pool2D_get_padding(self, padH, padW)
            }
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Pool2D_Pool2D(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _weight,
                    _type,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Pool2D_Pool2D_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D17get_int_parameterENS_11PMParameterEPi"]
            pub fn Pool2D_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D7forwardEb"]
            pub fn Pool2D_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D3mapEv"]
            pub fn Pool2D_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D5unmapEv"]
            pub fn Pool2D_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Pool2D13collect_costsERfS1_S1_Ri"]
            pub fn Pool2D_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Activation {
            pub _base: root::taso::OpBase,
            pub inPlace: bool,
        }
        #[test]
        fn bindgen_test_layout_Activation() {
            assert_eq!(
                ::std::mem::size_of::<Activation>(),
                13864usize,
                concat!("Size of: ", stringify!(Activation))
            );
            assert_eq!(
                ::std::mem::align_of::<Activation>(),
                8usize,
                concat!("Alignment of ", stringify!(Activation))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Activation>())).inPlace as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Activation),
                    "::",
                    stringify!(inPlace)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ActivationC1EPNS_5ModelENS_6TensorENS_6OpTypeEb"]
            pub fn Activation_Activation(
                this: *mut root::taso::Activation,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10ActivationD1Ev"]
            pub fn Activation_Activation_destructor(this: *mut root::taso::Activation);
        }
        impl Activation {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Activation_Activation(__bindgen_tmp.as_mut_ptr(), _model, _input, _type, _inPlace);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Activation_Activation_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation17get_int_parameterENS_11PMParameterEPi"]
            pub fn Activation_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation7forwardEb"]
            pub fn Activation_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation3mapEv"]
            pub fn Activation_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation5unmapEv"]
            pub fn Activation_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso10Activation13collect_costsERfS1_S1_Ri"]
            pub fn Activation_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct BatchNorm {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_BatchNorm() {
            assert_eq!(
                ::std::mem::size_of::<BatchNorm>(),
                13856usize,
                concat!("Size of: ", stringify!(BatchNorm))
            );
            assert_eq!(
                ::std::mem::align_of::<BatchNorm>(),
                8usize,
                concat!("Alignment of ", stringify!(BatchNorm))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNormC1EPNS_5ModelENS_6TensorES3_S3_S3_S3_"]
            pub fn BatchNorm_BatchNorm(
                this: *mut root::taso::BatchNorm,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _scale: root::taso::Tensor,
                _bias: root::taso::Tensor,
                _mean: root::taso::Tensor,
                _var: root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNormD1Ev"]
            pub fn BatchNorm_BatchNorm_destructor(this: *mut root::taso::BatchNorm);
        }
        impl BatchNorm {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _scale: root::taso::Tensor,
                _bias: root::taso::Tensor,
                _mean: root::taso::Tensor,
                _var: root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                BatchNorm_BatchNorm(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _scale,
                    _bias,
                    _mean,
                    _var,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                BatchNorm_BatchNorm_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm17get_int_parameterENS_11PMParameterEPi"]
            pub fn BatchNorm_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm7forwardEb"]
            pub fn BatchNorm_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm3mapEv"]
            pub fn BatchNorm_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm5unmapEv"]
            pub fn BatchNorm_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9BatchNorm13collect_costsERfS1_S1_Ri"]
            pub fn BatchNorm_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Cast {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Cast() {
            assert_eq!(
                ::std::mem::size_of::<Cast>(),
                13856usize,
                concat!("Size of: ", stringify!(Cast))
            );
            assert_eq!(
                ::std::mem::align_of::<Cast>(),
                8usize,
                concat!("Alignment of ", stringify!(Cast))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4CastC1EPNS_5ModelERKNS_6TensorENS_8DataTypeE"]
            pub fn Cast_Cast(
                this: *mut root::taso::Cast,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4CastD1Ev"]
            pub fn Cast_Cast_destructor(this: *mut root::taso::Cast);
        }
        impl Cast {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Cast_Cast(__bindgen_tmp.as_mut_ptr(), _model, _input, _datatype);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Cast_Cast_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast17get_int_parameterENS_11PMParameterEPi"]
            pub fn Cast_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast7forwardEb"]
            pub fn Cast_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast3mapEv"]
            pub fn Cast_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast5unmapEv"]
            pub fn Cast_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4Cast13collect_costsERfS1_S1_Ri"]
            pub fn Cast_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Concat {
            pub _base: root::taso::OpBase,
            pub axis: ::std::os::raw::c_int,
            pub needCopy: [bool; 6usize],
        }
        #[test]
        fn bindgen_test_layout_Concat() {
            assert_eq!(
                ::std::mem::size_of::<Concat>(),
                13872usize,
                concat!("Size of: ", stringify!(Concat))
            );
            assert_eq!(
                ::std::mem::align_of::<Concat>(),
                8usize,
                concat!("Alignment of ", stringify!(Concat))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Concat>())).axis as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Concat),
                    "::",
                    stringify!(axis)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Concat>())).needCopy as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Concat),
                    "::",
                    stringify!(needCopy)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ConcatC1EPNS_5ModelEiiPNS_6TensorEPb"]
            pub fn Concat_Concat(
                this: *mut root::taso::Concat,
                _model: *mut root::taso::Model,
                _axis: ::std::os::raw::c_int,
                _n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ConcatD1Ev"]
            pub fn Concat_Concat_destructor(this: *mut root::taso::Concat);
        }
        impl Concat {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _axis: ::std::os::raw::c_int,
                _n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Concat_Concat(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _axis,
                    _n,
                    _inputs,
                    _needCopy,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Concat_Concat_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat17get_int_parameterENS_11PMParameterEPi"]
            pub fn Concat_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat7forwardEb"]
            pub fn Concat_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat3mapEv"]
            pub fn Concat_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat5unmapEv"]
            pub fn Concat_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Concat13collect_costsERfS1_S1_Ri"]
            pub fn Concat_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Element {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Element() {
            assert_eq!(
                ::std::mem::size_of::<Element>(),
                13856usize,
                concat!("Size of: ", stringify!(Element))
            );
            assert_eq!(
                ::std::mem::align_of::<Element>(),
                8usize,
                concat!("Alignment of ", stringify!(Element))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZNK4taso7Element16has_cudnn_kernelEv"]
            pub fn Element_has_cudnn_kernel(this: *const root::taso::Element) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ElementC1EPNS_5ModelENS_6OpTypeERKNS_6TensorES6_"]
            pub fn Element_Element(
                this: *mut root::taso::Element,
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
                _t1: *const root::taso::Tensor,
                _t2: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ElementD1Ev"]
            pub fn Element_Element_destructor(this: *mut root::taso::Element);
        }
        impl Element {
            #[inline]
            pub unsafe fn has_cudnn_kernel(&self) -> bool {
                Element_has_cudnn_kernel(self)
            }
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _type: root::taso::OpType,
                _t1: *const root::taso::Tensor,
                _t2: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Element_Element(__bindgen_tmp.as_mut_ptr(), _model, _type, _t1, _t2);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Element_Element_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element17get_int_parameterENS_11PMParameterEPi"]
            pub fn Element_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element7forwardEb"]
            pub fn Element_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element3mapEv"]
            pub fn Element_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element5unmapEv"]
            pub fn Element_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Element13collect_costsERfS1_S1_Ri"]
            pub fn Element_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct ElementWiseUnary {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_ElementWiseUnary() {
            assert_eq!(
                ::std::mem::size_of::<ElementWiseUnary>(),
                13856usize,
                concat!("Size of: ", stringify!(ElementWiseUnary))
            );
            assert_eq!(
                ::std::mem::align_of::<ElementWiseUnary>(),
                8usize,
                concat!("Alignment of ", stringify!(ElementWiseUnary))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnaryC1EPNS_5ModelERKNS_6TensorENS_6OpTypeE"]
            pub fn ElementWiseUnary_ElementWiseUnary(
                this: *mut root::taso::ElementWiseUnary,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnaryD1Ev"]
            pub fn ElementWiseUnary_ElementWiseUnary_destructor(
                this: *mut root::taso::ElementWiseUnary,
            );
        }
        impl ElementWiseUnary {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                ElementWiseUnary_ElementWiseUnary(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _type,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                ElementWiseUnary_ElementWiseUnary_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary17get_int_parameterENS_11PMParameterEPi"]
            pub fn ElementWiseUnary_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary7forwardEb"]
            pub fn ElementWiseUnary_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary3mapEv"]
            pub fn ElementWiseUnary_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary5unmapEv"]
            pub fn ElementWiseUnary_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso16ElementWiseUnary13collect_costsERfS1_S1_Ri"]
            pub fn ElementWiseUnary_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Enlarge {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Enlarge() {
            assert_eq!(
                ::std::mem::size_of::<Enlarge>(),
                13856usize,
                concat!("Size of: ", stringify!(Enlarge))
            );
            assert_eq!(
                ::std::mem::align_of::<Enlarge>(),
                8usize,
                concat!("Alignment of ", stringify!(Enlarge))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7EnlargeC1EPNS_5ModelENS_6TensorES3_"]
            pub fn Enlarge_Enlarge(
                this: *mut root::taso::Enlarge,
                _model: *mut root::taso::Model,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7EnlargeD1Ev"]
            pub fn Enlarge_Enlarge_destructor(this: *mut root::taso::Enlarge);
        }
        impl Enlarge {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Enlarge_Enlarge(__bindgen_tmp.as_mut_ptr(), _model, _w1, _w2);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Enlarge_Enlarge_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge17get_int_parameterENS_11PMParameterEPi"]
            pub fn Enlarge_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge7forwardEb"]
            pub fn Enlarge_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge3mapEv"]
            pub fn Enlarge_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge5unmapEv"]
            pub fn Enlarge_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Enlarge13collect_costsERfS1_S1_Ri"]
            pub fn Enlarge_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct TopK {
            pub _base: root::taso::OpBase,
            pub axis: ::std::os::raw::c_int,
            pub largest: bool,
            pub sorted: bool,
        }
        #[test]
        fn bindgen_test_layout_TopK() {
            assert_eq!(
                ::std::mem::size_of::<TopK>(),
                13864usize,
                concat!("Size of: ", stringify!(TopK))
            );
            assert_eq!(
                ::std::mem::align_of::<TopK>(),
                8usize,
                concat!("Alignment of ", stringify!(TopK))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopK>())).axis as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopK),
                    "::",
                    stringify!(axis)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopK>())).largest as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopK),
                    "::",
                    stringify!(largest)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<TopK>())).sorted as *const _ as usize },
                13861usize,
                concat!(
                    "Offset of field: ",
                    stringify!(TopK),
                    "::",
                    stringify!(sorted)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopKC1EPNS_5ModelERKNS_6TensorEiibb"]
            pub fn TopK_TopK(
                this: *mut root::taso::TopK,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopKD1Ev"]
            pub fn TopK_TopK_destructor(this: *mut root::taso::TopK);
        }
        impl TopK {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                TopK_TopK(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _axis,
                    _numk,
                    _largest,
                    _sorted,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                TopK_TopK_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK17get_int_parameterENS_11PMParameterEPi"]
            pub fn TopK_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK7forwardEb"]
            pub fn TopK_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK3mapEv"]
            pub fn TopK_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK5unmapEv"]
            pub fn TopK_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso4TopK13collect_costsERfS1_S1_Ri"]
            pub fn TopK_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Pad {
            pub _base: root::taso::OpBase,
            pub pad_before: [u64; 3usize],
            pub pad_after: [u64; 3usize],
            pub pad_value: f32,
        }
        #[test]
        fn bindgen_test_layout_Pad() {
            assert_eq!(
                ::std::mem::size_of::<Pad>(),
                13912usize,
                concat!("Size of: ", stringify!(Pad))
            );
            assert_eq!(
                ::std::mem::align_of::<Pad>(),
                8usize,
                concat!("Alignment of ", stringify!(Pad))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pad>())).pad_before as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pad),
                    "::",
                    stringify!(pad_before)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pad>())).pad_after as *const _ as usize },
                13880usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pad),
                    "::",
                    stringify!(pad_after)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Pad>())).pad_value as *const _ as usize },
                13904usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Pad),
                    "::",
                    stringify!(pad_value)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3PadC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEESA_f"]
            pub fn Pad_Pad(
                this: *mut root::taso::Pad,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3PadD1Ev"]
            pub fn Pad_Pad_destructor(this: *mut root::taso::Pad);
        }
        impl Pad {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Pad_Pad(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _pad_before,
                    _pad_after,
                    _pad_value,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Pad_Pad_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad17get_int_parameterENS_11PMParameterEPi"]
            pub fn Pad_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad7forwardEb"]
            pub fn Pad_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad3mapEv"]
            pub fn Pad_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad5unmapEv"]
            pub fn Pad_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso3Pad13collect_costsERfS1_S1_Ri"]
            pub fn Pad_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Reduce {
            pub _base: root::taso::OpBase,
            pub keepdims: bool,
            pub axes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Reduce() {
            assert_eq!(
                ::std::mem::size_of::<Reduce>(),
                13888usize,
                concat!("Size of: ", stringify!(Reduce))
            );
            assert_eq!(
                ::std::mem::align_of::<Reduce>(),
                8usize,
                concat!("Alignment of ", stringify!(Reduce))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Reduce>())).keepdims as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Reduce),
                    "::",
                    stringify!(keepdims)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Reduce>())).axes as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Reduce),
                    "::",
                    stringify!(axes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ReduceC1EPNS_5ModelERKNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn Reduce_Reduce(
                this: *mut root::taso::Reduce,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ReduceD1Ev"]
            pub fn Reduce_Reduce_destructor(this: *mut root::taso::Reduce);
        }
        impl Reduce {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Reduce_Reduce(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _type,
                    _axes,
                    _keepdims,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Reduce_Reduce_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce17get_int_parameterENS_11PMParameterEPi"]
            pub fn Reduce_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce7forwardEb"]
            pub fn Reduce_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce3mapEv"]
            pub fn Reduce_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce5unmapEv"]
            pub fn Reduce_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Reduce13collect_costsERfS1_S1_Ri"]
            pub fn Reduce_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Reshape {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Reshape() {
            assert_eq!(
                ::std::mem::size_of::<Reshape>(),
                13856usize,
                concat!("Size of: ", stringify!(Reshape))
            );
            assert_eq!(
                ::std::mem::align_of::<Reshape>(),
                8usize,
                concat!("Alignment of ", stringify!(Reshape))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ReshapeC1EPNS_5ModelENS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Reshape_Reshape(
                this: *mut root::taso::Reshape,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7ReshapeD1Ev"]
            pub fn Reshape_Reshape_destructor(this: *mut root::taso::Reshape);
        }
        impl Reshape {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Reshape_Reshape(__bindgen_tmp.as_mut_ptr(), _model, _input, shape);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Reshape_Reshape_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape17get_int_parameterENS_11PMParameterEPi"]
            pub fn Reshape_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape7forwardEb"]
            pub fn Reshape_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape3mapEv"]
            pub fn Reshape_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape5unmapEv"]
            pub fn Reshape_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Reshape13collect_costsERfS1_S1_Ri"]
            pub fn Reshape_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Resize {
            pub _base: root::taso::OpBase,
            pub shape: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Resize() {
            assert_eq!(
                ::std::mem::size_of::<Resize>(),
                13880usize,
                concat!("Size of: ", stringify!(Resize))
            );
            assert_eq!(
                ::std::mem::align_of::<Resize>(),
                8usize,
                concat!("Alignment of ", stringify!(Resize))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Resize>())).shape as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Resize),
                    "::",
                    stringify!(shape)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ResizeC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Resize_Resize(
                this: *mut root::taso::Resize,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6ResizeD1Ev"]
            pub fn Resize_Resize_destructor(this: *mut root::taso::Resize);
        }
        impl Resize {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Resize_Resize(__bindgen_tmp.as_mut_ptr(), _model, _input, _shape);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Resize_Resize_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize17get_int_parameterENS_11PMParameterEPi"]
            pub fn Resize_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize7forwardEb"]
            pub fn Resize_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize3mapEv"]
            pub fn Resize_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize5unmapEv"]
            pub fn Resize_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso6Resize13collect_costsERfS1_S1_Ri"]
            pub fn Resize_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Shape {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Shape() {
            assert_eq!(
                ::std::mem::size_of::<Shape>(),
                13856usize,
                concat!("Size of: ", stringify!(Shape))
            );
            assert_eq!(
                ::std::mem::align_of::<Shape>(),
                8usize,
                concat!("Alignment of ", stringify!(Shape))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5ShapeC1EPNS_5ModelERKNS_6TensorENS_6OpTypeE"]
            pub fn Shape_Shape(
                this: *mut root::taso::Shape,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5ShapeD1Ev"]
            pub fn Shape_Shape_destructor(this: *mut root::taso::Shape);
        }
        impl Shape {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Shape_Shape(__bindgen_tmp.as_mut_ptr(), _model, _input, _type);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Shape_Shape_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape17get_int_parameterENS_11PMParameterEPi"]
            pub fn Shape_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape7forwardEb"]
            pub fn Shape_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape3mapEv"]
            pub fn Shape_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape5unmapEv"]
            pub fn Shape_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Shape13collect_costsERfS1_S1_Ri"]
            pub fn Shape_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Slice {
            pub _base: root::taso::OpBase,
            pub start: [u64; 3usize],
            pub end: [u64; 3usize],
            pub axes: [u64; 3usize],
            pub steps: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Slice() {
            assert_eq!(
                ::std::mem::size_of::<Slice>(),
                13952usize,
                concat!("Size of: ", stringify!(Slice))
            );
            assert_eq!(
                ::std::mem::align_of::<Slice>(),
                8usize,
                concat!("Alignment of ", stringify!(Slice))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).start as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(start)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).end as *const _ as usize },
                13880usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(end)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).axes as *const _ as usize },
                13904usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(axes)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Slice>())).steps as *const _ as usize },
                13928usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Slice),
                    "::",
                    stringify!(steps)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SliceC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEESA_SA_SA_"]
            pub fn Slice_Slice(
                this: *mut root::taso::Slice,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SliceD1Ev"]
            pub fn Slice_Slice_destructor(this: *mut root::taso::Slice);
        }
        impl Slice {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Slice_Slice(
                    __bindgen_tmp.as_mut_ptr(),
                    _model,
                    _input,
                    _start,
                    _end,
                    _axes,
                    _steps,
                );
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Slice_Slice_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice17get_int_parameterENS_11PMParameterEPi"]
            pub fn Slice_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice7forwardEb"]
            pub fn Slice_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice3mapEv"]
            pub fn Slice_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice5unmapEv"]
            pub fn Slice_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Slice13collect_costsERfS1_S1_Ri"]
            pub fn Slice_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Split {
            pub _base: root::taso::OpBase,
            pub axis: ::std::os::raw::c_int,
            pub sizes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Split() {
            assert_eq!(
                ::std::mem::size_of::<Split>(),
                13888usize,
                concat!("Size of: ", stringify!(Split))
            );
            assert_eq!(
                ::std::mem::align_of::<Split>(),
                8usize,
                concat!("Alignment of ", stringify!(Split))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Split>())).axis as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Split),
                    "::",
                    stringify!(axis)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Split>())).sizes as *const _ as usize },
                13864usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Split),
                    "::",
                    stringify!(sizes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SplitC1EPNS_5ModelERKNS_6TensorEiRKSt6vectorIiSaIiEE"]
            pub fn Split_Split(
                this: *mut root::taso::Split,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5SplitD1Ev"]
            pub fn Split_Split_destructor(this: *mut root::taso::Split);
        }
        impl Split {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Split_Split(__bindgen_tmp.as_mut_ptr(), _model, _input, axis, _sizes);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Split_Split_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split17get_int_parameterENS_11PMParameterEPi"]
            pub fn Split_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split7forwardEb"]
            pub fn Split_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split3mapEv"]
            pub fn Split_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split5unmapEv"]
            pub fn Split_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Split13collect_costsERfS1_S1_Ri"]
            pub fn Split_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Squeeze {
            pub _base: root::taso::OpBase,
            pub axes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Squeeze() {
            assert_eq!(
                ::std::mem::size_of::<Squeeze>(),
                13880usize,
                concat!("Size of: ", stringify!(Squeeze))
            );
            assert_eq!(
                ::std::mem::align_of::<Squeeze>(),
                8usize,
                concat!("Alignment of ", stringify!(Squeeze))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Squeeze>())).axes as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Squeeze),
                    "::",
                    stringify!(axes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7SqueezeC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Squeeze_Squeeze(
                this: *mut root::taso::Squeeze,
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7SqueezeD1Ev"]
            pub fn Squeeze_Squeeze_destructor(this: *mut root::taso::Squeeze);
        }
        impl Squeeze {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Squeeze_Squeeze(__bindgen_tmp.as_mut_ptr(), _model, input, axes);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Squeeze_Squeeze_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze17get_int_parameterENS_11PMParameterEPi"]
            pub fn Squeeze_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze7forwardEb"]
            pub fn Squeeze_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze3mapEv"]
            pub fn Squeeze_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze5unmapEv"]
            pub fn Squeeze_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso7Squeeze13collect_costsERfS1_S1_Ri"]
            pub fn Squeeze_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Transpose {
            pub _base: root::taso::OpBase,
            pub permIdx: ::std::os::raw::c_int,
            pub shuffle: bool,
        }
        #[test]
        fn bindgen_test_layout_Transpose() {
            assert_eq!(
                ::std::mem::size_of::<Transpose>(),
                13864usize,
                concat!("Size of: ", stringify!(Transpose))
            );
            assert_eq!(
                ::std::mem::align_of::<Transpose>(),
                8usize,
                concat!("Alignment of ", stringify!(Transpose))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Transpose>())).permIdx as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transpose),
                    "::",
                    stringify!(permIdx)
                )
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Transpose>())).shuffle as *const _ as usize },
                13860usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Transpose),
                    "::",
                    stringify!(shuffle)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9TransposeC1EPNS_5ModelENS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Transpose_Transpose(
                this: *mut root::taso::Transpose,
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                perm: *const [u64; 3usize],
                _shuffle: bool,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9TransposeD1Ev"]
            pub fn Transpose_Transpose_destructor(this: *mut root::taso::Transpose);
        }
        impl Transpose {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: root::taso::Tensor,
                perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Transpose_Transpose(__bindgen_tmp.as_mut_ptr(), _model, _input, perm, _shuffle);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Transpose_Transpose_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose17get_int_parameterENS_11PMParameterEPi"]
            pub fn Transpose_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose7forwardEb"]
            pub fn Transpose_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose3mapEv"]
            pub fn Transpose_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose5unmapEv"]
            pub fn Transpose_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Transpose13collect_costsERfS1_S1_Ri"]
            pub fn Transpose_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Unsqueeze {
            pub _base: root::taso::OpBase,
            pub axes: [u64; 3usize],
        }
        #[test]
        fn bindgen_test_layout_Unsqueeze() {
            assert_eq!(
                ::std::mem::size_of::<Unsqueeze>(),
                13880usize,
                concat!("Size of: ", stringify!(Unsqueeze))
            );
            assert_eq!(
                ::std::mem::align_of::<Unsqueeze>(),
                8usize,
                concat!("Alignment of ", stringify!(Unsqueeze))
            );
            assert_eq!(
                unsafe { &(*(::std::ptr::null::<Unsqueeze>())).axes as *const _ as usize },
                13856usize,
                concat!(
                    "Offset of field: ",
                    stringify!(Unsqueeze),
                    "::",
                    stringify!(axes)
                )
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9UnsqueezeC1EPNS_5ModelERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Unsqueeze_Unsqueeze(
                this: *mut root::taso::Unsqueeze,
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9UnsqueezeD1Ev"]
            pub fn Unsqueeze_Unsqueeze_destructor(this: *mut root::taso::Unsqueeze);
        }
        impl Unsqueeze {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Unsqueeze_Unsqueeze(__bindgen_tmp.as_mut_ptr(), _model, input, axes);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Unsqueeze_Unsqueeze_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze17get_int_parameterENS_11PMParameterEPi"]
            pub fn Unsqueeze_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze7forwardEb"]
            pub fn Unsqueeze_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze3mapEv"]
            pub fn Unsqueeze_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze5unmapEv"]
            pub fn Unsqueeze_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso9Unsqueeze13collect_costsERfS1_S1_Ri"]
            pub fn Unsqueeze_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        pub struct Where {
            pub _base: root::taso::OpBase,
        }
        #[test]
        fn bindgen_test_layout_Where() {
            assert_eq!(
                ::std::mem::size_of::<Where>(),
                13856usize,
                concat!("Size of: ", stringify!(Where))
            );
            assert_eq!(
                ::std::mem::align_of::<Where>(),
                8usize,
                concat!("Alignment of ", stringify!(Where))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5WhereC1EPNS_5ModelERKNS_6TensorES5_S5_"]
            pub fn Where_Where(
                this: *mut root::taso::Where,
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5WhereD1Ev"]
            pub fn Where_Where_destructor(this: *mut root::taso::Where);
        }
        impl Where {
            #[inline]
            pub unsafe fn new(
                _model: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Where_Where(__bindgen_tmp.as_mut_ptr(), _model, _input, _x, _y);
                __bindgen_tmp.assume_init()
            }
            #[inline]
            pub unsafe fn destruct(&mut self) {
                Where_Where_destructor(self)
            }
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where17get_int_parameterENS_11PMParameterEPi"]
            pub fn Where_get_int_parameter(
                this: *mut ::std::os::raw::c_void,
                para: root::taso::PMParameter,
                arg1: *mut ::std::os::raw::c_int,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where7forwardEb"]
            pub fn Where_forward(this: *mut ::std::os::raw::c_void, block: bool);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where3mapEv"]
            pub fn Where_map(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where5unmapEv"]
            pub fn Where_unmap(this: *mut ::std::os::raw::c_void);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Where13collect_costsERfS1_S1_Ri"]
            pub fn Where_collect_costs(
                this: *mut ::std::os::raw::c_void,
                exe_time: *mut f32,
                flops: *mut f32,
                mem_acc: *mut f32,
                num_kernels: *mut ::std::os::raw::c_int,
            );
        }
        #[repr(C)]
        #[repr(align(8))]
        pub struct Model {
            pub _bindgen_opaque_blob: [u64; 169usize],
        }
        #[test]
        fn bindgen_test_layout_Model() {
            assert_eq!(
                ::std::mem::size_of::<Model>(),
                1352usize,
                concat!("Size of: ", stringify!(Model))
            );
            assert_eq!(
                ::std::mem::align_of::<Model>(),
                8usize,
                concat!("Alignment of ", stringify!(Model))
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model24get_or_create_activationENS_6TensorENS_6OpTypeEb"]
            pub fn Model_get_or_create_activation(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_batchnormENS_6TensorES1_S1_S1_S1_"]
            pub fn Model_get_or_create_batchnorm(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _scale: root::taso::Tensor,
                _bias: root::taso::Tensor,
                _mean: root::taso::Tensor,
                _var: root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18get_or_create_castERKNS_6TensorENS_8DataTypeE"]
            pub fn Model_get_or_create_cast(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_concatEiiPNS_6TensorEPb"]
            pub fn Model_get_or_create_concat(
                this: *mut root::taso::Model,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22get_or_create_constantEiPiNS_6OpTypeE"]
            pub fn Model_get_or_create_constant(
                this: *mut root::taso::Model,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                type_: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_conv2dENS_6TensorES1_iiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Model_get_or_create_conv2d(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_elementENS_6OpTypeERKNS_6TensorES4_"]
            pub fn Model_get_or_create_element(
                this: *mut root::taso::Model,
                type_: root::taso::OpType,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model31get_or_create_elementwise_unaryERKNS_6TensorENS_6OpTypeE"]
            pub fn Model_get_or_create_elementwise_unary(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_enlargeENS_6TensorES1_"]
            pub fn Model_get_or_create_enlarge(
                this: *mut root::taso::Model,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_matmulENS_6TensorES1_NS_8ActiModeE"]
            pub fn Model_get_or_create_matmul(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actimode: root::taso::ActiMode,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17get_or_create_mulERKNS_6TensorES3_"]
            pub fn Model_get_or_create_mul(
                this: *mut root::taso::Model,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17get_or_create_padERKNS_6TensorERKSt6vectorIiSaIiEES8_f"]
            pub fn Model_get_or_create_pad(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_pool2dENS_6TensorES1_NS_6OpTypeEiiiiNS_11PaddingModeENS_8ActiModeE"]
            pub fn Model_get_or_create_pool2d(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_reduceERKNS_6TensorENS_6OpTypeERKSt6vectorIiSaIiEEb"]
            pub fn Model_get_or_create_reduce(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_reshapeENS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_reshape(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20get_or_create_resizeERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_resize(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_shapeERKNS_6TensorENS_6OpTypeE"]
            pub fn Model_get_or_create_shape(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_sliceERKNS_6TensorERKSt6vectorIiSaIiEES8_S8_S8_"]
            pub fn Model_get_or_create_slice(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model21get_or_create_squeezeERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_squeeze(
                this: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_splitERKNS_6TensorEiRKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_split(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_splitERKNS_6TensorEii"]
            pub fn Model_get_or_create_split1(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18get_or_create_topkERKNS_6TensorEiibb"]
            pub fn Model_get_or_create_topk(
                this: *mut root::taso::Model,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_transposeENS_6TensorERKSt6vectorIiSaIiEEb"]
            pub fn Model_get_or_create_transpose(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_transposeENS_6TensorEib"]
            pub fn Model_get_or_create_transpose1(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                permIdx: ::std::os::raw::c_int,
                _shuffle: bool,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18get_or_create_noopENS_6TensorENS_6OpTypeE"]
            pub fn Model_get_or_create_noop(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model25get_or_create_merge_gconvERKNS_6TensorEi"]
            pub fn Model_get_or_create_merge_gconv(
                this: *mut root::taso::Model,
                _weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23get_or_create_unsqueezeERKNS_6TensorERKSt6vectorIiSaIiEE"]
            pub fn Model_get_or_create_unsqueeze(
                this: *mut root::taso::Model,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19get_or_create_whereERKNS_6TensorES3_S3_"]
            pub fn Model_get_or_create_where(
                this: *mut root::taso::Model,
                _cond: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model12create_inputENS_6TensorENS_6OpTypeE"]
            pub fn Model_create_input(
                this: *mut root::taso::Model,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model13create_weightENS_6TensorENS_6OpTypeE"]
            pub fn Model_create_weight(
                this: *mut root::taso::Model,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_conv2d_costEPNS_6Conv2DE"]
            pub fn Model_measure_conv2d_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Conv2D,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_matmul_costEPNS_6MatmulE"]
            pub fn Model_measure_matmul_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Matmul,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model16measure_mul_costEPNS_3MulE"]
            pub fn Model_measure_mul_cost(this: *mut root::taso::Model, arg1: *mut root::taso::Mul);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model16measure_pad_costEPNS_3PadE"]
            pub fn Model_measure_pad_cost(this: *mut root::taso::Model, arg1: *mut root::taso::Pad);
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_pool2d_costEPNS_6Pool2DE"]
            pub fn Model_measure_pool2d_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Pool2D,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17measure_topk_costEPNS_4TopKE"]
            pub fn Model_measure_topk_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::TopK,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_transpose_costEPNS_9TransposeE"]
            pub fn Model_measure_transpose_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Transpose,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_reduce_costEPNS_6ReduceE"]
            pub fn Model_measure_reduce_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Reduce,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_reshape_costEPNS_7ReshapeE"]
            pub fn Model_measure_reshape_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Reshape,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_resize_costEPNS_6ResizeE"]
            pub fn Model_measure_resize_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Resize,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model23measure_activation_costEPNS_10ActivationE"]
            pub fn Model_measure_activation_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Activation,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_batchnorm_costEPNS_9BatchNormE"]
            pub fn Model_measure_batchnorm_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::BatchNorm,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model17measure_cast_costEPNS_4CastE"]
            pub fn Model_measure_cast_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Cast,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model19measure_concat_costEPNS_6ConcatE"]
            pub fn Model_measure_concat_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Concat,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_shape_costEPNS_5ShapeE"]
            pub fn Model_measure_shape_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Shape,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_slice_costEPNS_5SliceE"]
            pub fn Model_measure_slice_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Slice,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_split_costEPNS_5SplitE"]
            pub fn Model_measure_split_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Split,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_element_costEPNS_7ElementE"]
            pub fn Model_measure_element_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Element,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model30measure_elementwise_unary_costEPNS_16ElementWiseUnaryE"]
            pub fn Model_measure_elementwise_unary_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::ElementWiseUnary,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_enlarge_costEPNS_7EnlargeE"]
            pub fn Model_measure_enlarge_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Enlarge,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model20measure_squeeze_costEPNS_7SqueezeE"]
            pub fn Model_measure_squeeze_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Squeeze,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_unsqueeze_costEPNS_9UnsqueezeE"]
            pub fn Model_measure_unsqueeze_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Unsqueeze,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model18measure_where_costEPNS_5WhereE"]
            pub fn Model_measure_where_cost(
                this: *mut root::taso::Model,
                arg1: *mut root::taso::Where,
            );
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model15allocate_memoryEmPKf"]
            pub fn Model_allocate_memory(
                this: *mut root::taso::Model,
                size: root::size_t,
                initial_data: *const root::taso::DATATYPE,
            ) -> *mut ::std::os::raw::c_void;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model11copy_memoryEPfPKfm"]
            pub fn Model_copy_memory(
                this: *mut root::taso::Model,
                dst: *mut root::taso::DATATYPE,
                src: *const root::taso::DATATYPE,
                size: root::size_t,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model22measure_oplist_runtimeERKSt6vectorIPNS_6OpBaseESaIS3_EE"]
            pub fn Model_measure_oplist_runtime(
                this: *mut root::taso::Model,
                list: *const u8,
            ) -> f32;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5Model13broadcastableERKNS_6TensorES3_"]
            pub fn Model_broadcastable(
                this: *mut root::taso::Model,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> bool;
        }
        extern "C" {
            #[link_name = "\u{1}_ZN4taso5ModelC1Ev"]
            pub fn Model_Model(this: *mut root::taso::Model);
        }
        impl Model {
            #[inline]
            pub unsafe fn get_or_create_activation(
                &mut self,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
                _inPlace: bool,
            ) -> root::taso::Op {
                Model_get_or_create_activation(self, _input, _type, _inPlace)
            }
            #[inline]
            pub unsafe fn get_or_create_batchnorm(
                &mut self,
                _input: root::taso::Tensor,
                _scale: root::taso::Tensor,
                _bias: root::taso::Tensor,
                _mean: root::taso::Tensor,
                _var: root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_batchnorm(self, _input, _scale, _bias, _mean, _var)
            }
            #[inline]
            pub unsafe fn get_or_create_cast(
                &mut self,
                _input: *const root::taso::Tensor,
                _datatype: root::taso::DataType,
            ) -> root::taso::Op {
                Model_get_or_create_cast(self, _input, _datatype)
            }
            #[inline]
            pub unsafe fn get_or_create_concat(
                &mut self,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
                _inputs: *mut root::taso::Tensor,
                _needCopy: *mut bool,
            ) -> root::taso::Op {
                Model_get_or_create_concat(self, axis, n, _inputs, _needCopy)
            }
            #[inline]
            pub unsafe fn get_or_create_constant(
                &mut self,
                ndim: ::std::os::raw::c_int,
                dims: *mut ::std::os::raw::c_int,
                type_: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_constant(self, ndim, dims, type_)
            }
            #[inline]
            pub unsafe fn get_or_create_conv2d(
                &mut self,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op {
                Model_get_or_create_conv2d(
                    self,
                    _input,
                    _weight,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn get_or_create_element(
                &mut self,
                type_: root::taso::OpType,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_element(self, type_, t1, t2)
            }
            #[inline]
            pub unsafe fn get_or_create_elementwise_unary(
                &mut self,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_elementwise_unary(self, _input, _type)
            }
            #[inline]
            pub unsafe fn get_or_create_enlarge(
                &mut self,
                _w1: root::taso::Tensor,
                _w2: root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_enlarge(self, _w1, _w2)
            }
            #[inline]
            pub unsafe fn get_or_create_matmul(
                &mut self,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _actimode: root::taso::ActiMode,
            ) -> root::taso::Op {
                Model_get_or_create_matmul(self, _input, _weight, _actimode)
            }
            #[inline]
            pub unsafe fn get_or_create_mul(
                &mut self,
                x: *const root::taso::Tensor,
                y: *const root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_mul(self, x, y)
            }
            #[inline]
            pub unsafe fn get_or_create_pad(
                &mut self,
                _input: *const root::taso::Tensor,
                _pad_before: *const [u64; 3usize],
                _pad_after: *const [u64; 3usize],
                _pad_value: f32,
            ) -> root::taso::Op {
                Model_get_or_create_pad(self, _input, _pad_before, _pad_after, _pad_value)
            }
            #[inline]
            pub unsafe fn get_or_create_pool2d(
                &mut self,
                _input: root::taso::Tensor,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
                _kernelH: ::std::os::raw::c_int,
                _kernelW: ::std::os::raw::c_int,
                _strideH: ::std::os::raw::c_int,
                _strideW: ::std::os::raw::c_int,
                _padding: root::taso::PaddingMode,
                _activation: root::taso::ActiMode,
            ) -> root::taso::Op {
                Model_get_or_create_pool2d(
                    self,
                    _input,
                    _weight,
                    _type,
                    _kernelH,
                    _kernelW,
                    _strideH,
                    _strideW,
                    _padding,
                    _activation,
                )
            }
            #[inline]
            pub unsafe fn get_or_create_reduce(
                &mut self,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
                _axes: *const [u64; 3usize],
                _keepdims: bool,
            ) -> root::taso::Op {
                Model_get_or_create_reduce(self, _input, _type, _axes, _keepdims)
            }
            #[inline]
            pub unsafe fn get_or_create_reshape(
                &mut self,
                _input: root::taso::Tensor,
                shape: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_reshape(self, _input, shape)
            }
            #[inline]
            pub unsafe fn get_or_create_resize(
                &mut self,
                _input: *const root::taso::Tensor,
                _shape: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_resize(self, _input, _shape)
            }
            #[inline]
            pub unsafe fn get_or_create_shape(
                &mut self,
                _input: *const root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_shape(self, _input, _type)
            }
            #[inline]
            pub unsafe fn get_or_create_slice(
                &mut self,
                _input: *const root::taso::Tensor,
                _start: *const [u64; 3usize],
                _end: *const [u64; 3usize],
                _axes: *const [u64; 3usize],
                _steps: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_slice(self, _input, _start, _end, _axes, _steps)
            }
            #[inline]
            pub unsafe fn get_or_create_squeeze(
                &mut self,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_squeeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn get_or_create_split(
                &mut self,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _sizes: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_split(self, _input, _axis, _sizes)
            }
            #[inline]
            pub unsafe fn get_or_create_split1(
                &mut self,
                _input: *const root::taso::Tensor,
                axis: ::std::os::raw::c_int,
                n: ::std::os::raw::c_int,
            ) -> root::taso::Op {
                Model_get_or_create_split1(self, _input, axis, n)
            }
            #[inline]
            pub unsafe fn get_or_create_topk(
                &mut self,
                _input: *const root::taso::Tensor,
                _axis: ::std::os::raw::c_int,
                _numk: ::std::os::raw::c_int,
                _largest: bool,
                _sorted: bool,
            ) -> root::taso::Op {
                Model_get_or_create_topk(self, _input, _axis, _numk, _largest, _sorted)
            }
            #[inline]
            pub unsafe fn get_or_create_transpose(
                &mut self,
                _input: root::taso::Tensor,
                _perm: *const [u64; 3usize],
                _shuffle: bool,
            ) -> root::taso::Op {
                Model_get_or_create_transpose(self, _input, _perm, _shuffle)
            }
            #[inline]
            pub unsafe fn get_or_create_transpose1(
                &mut self,
                _input: root::taso::Tensor,
                permIdx: ::std::os::raw::c_int,
                _shuffle: bool,
            ) -> root::taso::Op {
                Model_get_or_create_transpose1(self, _input, permIdx, _shuffle)
            }
            #[inline]
            pub unsafe fn get_or_create_noop(
                &mut self,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_get_or_create_noop(self, _input, _type)
            }
            #[inline]
            pub unsafe fn get_or_create_merge_gconv(
                &mut self,
                _weight: *const root::taso::Tensor,
                count: ::std::os::raw::c_int,
            ) -> root::taso::Op {
                Model_get_or_create_merge_gconv(self, _weight, count)
            }
            #[inline]
            pub unsafe fn get_or_create_unsqueeze(
                &mut self,
                input: *const root::taso::Tensor,
                axes: *const [u64; 3usize],
            ) -> root::taso::Op {
                Model_get_or_create_unsqueeze(self, input, axes)
            }
            #[inline]
            pub unsafe fn get_or_create_where(
                &mut self,
                _cond: *const root::taso::Tensor,
                _x: *const root::taso::Tensor,
                _y: *const root::taso::Tensor,
            ) -> root::taso::Op {
                Model_get_or_create_where(self, _cond, _x, _y)
            }
            #[inline]
            pub unsafe fn create_input(
                &mut self,
                _input: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_create_input(self, _input, _type)
            }
            #[inline]
            pub unsafe fn create_weight(
                &mut self,
                _weight: root::taso::Tensor,
                _type: root::taso::OpType,
            ) -> root::taso::Op {
                Model_create_weight(self, _weight, _type)
            }
            #[inline]
            pub unsafe fn measure_conv2d_cost(&mut self, arg1: *mut root::taso::Conv2D) {
                Model_measure_conv2d_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_matmul_cost(&mut self, arg1: *mut root::taso::Matmul) {
                Model_measure_matmul_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_mul_cost(&mut self, arg1: *mut root::taso::Mul) {
                Model_measure_mul_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_pad_cost(&mut self, arg1: *mut root::taso::Pad) {
                Model_measure_pad_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_pool2d_cost(&mut self, arg1: *mut root::taso::Pool2D) {
                Model_measure_pool2d_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_topk_cost(&mut self, arg1: *mut root::taso::TopK) {
                Model_measure_topk_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_transpose_cost(&mut self, arg1: *mut root::taso::Transpose) {
                Model_measure_transpose_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_reduce_cost(&mut self, arg1: *mut root::taso::Reduce) {
                Model_measure_reduce_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_reshape_cost(&mut self, arg1: *mut root::taso::Reshape) {
                Model_measure_reshape_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_resize_cost(&mut self, arg1: *mut root::taso::Resize) {
                Model_measure_resize_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_activation_cost(&mut self, arg1: *mut root::taso::Activation) {
                Model_measure_activation_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_batchnorm_cost(&mut self, arg1: *mut root::taso::BatchNorm) {
                Model_measure_batchnorm_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_cast_cost(&mut self, arg1: *mut root::taso::Cast) {
                Model_measure_cast_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_concat_cost(&mut self, arg1: *mut root::taso::Concat) {
                Model_measure_concat_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_shape_cost(&mut self, arg1: *mut root::taso::Shape) {
                Model_measure_shape_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_slice_cost(&mut self, arg1: *mut root::taso::Slice) {
                Model_measure_slice_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_split_cost(&mut self, arg1: *mut root::taso::Split) {
                Model_measure_split_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_element_cost(&mut self, arg1: *mut root::taso::Element) {
                Model_measure_element_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_elementwise_unary_cost(
                &mut self,
                arg1: *mut root::taso::ElementWiseUnary,
            ) {
                Model_measure_elementwise_unary_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_enlarge_cost(&mut self, arg1: *mut root::taso::Enlarge) {
                Model_measure_enlarge_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_squeeze_cost(&mut self, arg1: *mut root::taso::Squeeze) {
                Model_measure_squeeze_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_unsqueeze_cost(&mut self, arg1: *mut root::taso::Unsqueeze) {
                Model_measure_unsqueeze_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn measure_where_cost(&mut self, arg1: *mut root::taso::Where) {
                Model_measure_where_cost(self, arg1)
            }
            #[inline]
            pub unsafe fn allocate_memory(
                &mut self,
                size: root::size_t,
                initial_data: *const root::taso::DATATYPE,
            ) -> *mut ::std::os::raw::c_void {
                Model_allocate_memory(self, size, initial_data)
            }
            #[inline]
            pub unsafe fn copy_memory(
                &mut self,
                dst: *mut root::taso::DATATYPE,
                src: *const root::taso::DATATYPE,
                size: root::size_t,
            ) -> bool {
                Model_copy_memory(self, dst, src, size)
            }
            #[inline]
            pub unsafe fn measure_oplist_runtime(&mut self, list: *const u8) -> f32 {
                Model_measure_oplist_runtime(self, list)
            }
            #[inline]
            pub unsafe fn broadcastable(
                &mut self,
                t1: *const root::taso::Tensor,
                t2: *const root::taso::Tensor,
            ) -> bool {
                Model_broadcastable(self, t1, t2)
            }
            #[inline]
            pub unsafe fn new() -> Self {
                let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
                Model_Model(__bindgen_tmp.as_mut_ptr());
                __bindgen_tmp.assume_init()
            }
        }
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_char_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[repr(C)]
    #[derive(Debug, Copy, Clone)]
    pub struct __locale_data {
        pub _address: u8,
    }
    #[test]
    fn __bindgen_test_layout_char_traits_open0_char_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::char_traits>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::char_traits)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_iterator_open0_output_iterator_tag_void_void_void_void_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::iterator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::iterator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::iterator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::iterator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_2() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_3() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_4() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_5() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_6() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_7() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_8() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_9() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_10() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_11() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_12() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_13() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_14() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_15() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_16() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_17() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_18() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_19() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_Op_set_open2_Edge_EdgeCompare_allocator_open3_Edge_close3_close2_close1_close0_instantiation(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_pair_open1_Op_set_open2_Edge_EdgeCompare_allocator_open3_Edge_close3_close2_close1_close0_instantiation_1(
    ) {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_Op_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_Op_close0_instantiation_1() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_Graph_GraphSubst_close0_instantiation() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_20() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_21() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_22() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_23() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_24() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_25() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_26() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_27() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_28() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_29() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_30() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_31() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_32() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_33() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_34() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_35() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_36() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_37() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_38() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_39() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_40() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_41() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_42() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_43() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_44() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_45() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_46() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_47() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_48() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_49() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_50() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_51() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_52() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_53() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_54() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_55() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
    #[test]
    fn __bindgen_test_layout_allocator_open0_int_close0_instantiation_56() {
        assert_eq!(
            ::std::mem::size_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Size of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
        assert_eq!(
            ::std::mem::align_of::<root::std::allocator>(),
            1usize,
            concat!(
                "Alignment of template specialization: ",
                stringify!(root::std::allocator)
            )
        );
    }
}
